<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>MySQL-实践一 | JJW-STORY</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="JJW-STORY">
  
  <meta name="description" content="普通索引和唯一索引的选择普通索引和唯一索引的查询过程对比例如：我们查询一个 where k=5 条件的SQL语句，这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，然后可以认为数据页内部通过二分法来定位记录。  对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。  对于唯一索引来说，由于">
<meta name="keywords" content="MySQL,实践一">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-实践一">
<meta property="og:url" content="https://jjw-story.github.io/2020/07/12/MySQL-实践一/index.html">
<meta property="og:site_name" content="JJW-STORY">
<meta property="og:description" content="普通索引和唯一索引的选择普通索引和唯一索引的查询过程对比例如：我们查询一个 where k=5 条件的SQL语句，这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，然后可以认为数据页内部通过二分法来定位记录。  对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。  对于唯一索引来说，由于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-11-26T09:11:00.557Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL-实践一">
<meta name="twitter:description" content="普通索引和唯一索引的选择普通索引和唯一索引的查询过程对比例如：我们查询一个 where k=5 条件的SQL语句，这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，然后可以认为数据页内部通过二分法来定位记录。  对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。  对于唯一索引来说，由于">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">JJW-STORY</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        JJW-STORY
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        技术记录
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="JJW-STORY" target="_blank" href="//jjw-story.github.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//jjw-story.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" target="_blank" href="/暂不开放">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="Twitter" target="_blank" href="/暂不开放">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-MySQL-实践一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      MySQL-实践一
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/MySQL/">MySQL</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-07-12
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="普通索引和唯一索引的选择"><a href="#普通索引和唯一索引的选择" class="headerlink" title="普通索引和唯一索引的选择"></a>普通索引和唯一索引的选择</h1><h2 id="普通索引和唯一索引的查询过程对比"><a href="#普通索引和唯一索引的查询过程对比" class="headerlink" title="普通索引和唯一索引的查询过程对比"></a>普通索引和唯一索引的查询过程对比</h2><p>例如：我们查询一个 where k=5 条件的SQL语句，这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，然后可以认为数据页内部通过二分法来定位记录。</p>
<ul>
<li><p>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。</p>
</li>
<li><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>
</li>
</ul>
<p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，<strong>而是以页为单位，将其整体读入内存</strong>。在 InnoDB 中，每个数据页的大小默认是 16KB。<br>因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。<br>当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。</p>
<p><strong>结论：这个索引不同查询带来的性能差距会有多少呢？答案是，微乎其微。</strong></p>
<h2 id="普通索引和唯一索引的更新过程对比"><a href="#普通索引和唯一索引的更新过程对比" class="headerlink" title="普通索引和唯一索引的更新过程对比"></a>普通索引和唯一索引的更新过程对比</h2><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p><strong>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</strong></p>
<p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<h3 id="唯一索引和普通索引对于change-buffer的应用特点对比"><a href="#唯一索引和普通索引对于change-buffer的应用特点对比" class="headerlink" title="唯一索引和普通索引对于change buffer的应用特点对比"></a>唯一索引和普通索引对于change buffer的应用特点对比</h3><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如我们要插入一条数据，而这必须要将数据页读入内存才能判断。<strong>如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</strong></p>
<p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</p>
<p><strong>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>
<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>
<h3 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h3><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。<br>对于写少读多的业务，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。</p>
<p>普通索引和唯一索引的选择结论：这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong>(这块还是有点不太理解，个人理解就是：WAL是数据页已经在内存中了，这时我们修改或插入此数据页数据，直接更新内存中的数据，然后写入redo log，系统在空闲的时候进行将操作更新到磁盘。 而 change buffer 主要解决的是数据页本身就不在内存中，这时候我们更新或者添加数据，就直接写入到change buffer中，等到需要读此数据页的数据时，才将此数据读入内存中，然后合并 change buffer中的修改)</p>
<h1 id="MySQL为什么有时候会选错索引"><a href="#MySQL为什么有时候会选错索引" class="headerlink" title="MySQL为什么有时候会选错索引"></a>MySQL为什么有时候会选错索引</h1><p>1：MySQL选错索引，啥意思？</p>
<p>我们认为使用K索引检索的速度会更快的，但是MySQL没有使用，决定使用什么索引是由Server层的优化器来决定的，她也是想选择最佳的方案来检索数据的，不过他也是人写的程序也是存在bug的。</p>
<p>2：MySQL为啥会选错索引？</p>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。优化器认为使用那个索引检索数据的速度比较快是一个需要各种因素综合评估的事情，比如：是否使用临时表、是否排序、扫描的行数多少、回表的次数等。</p>
<p>索引的创建是非常的耗时的，因为需要真正的建索引的过程，但是删除索引却不需要耗费太多时间，因为是标记删除，这个是以空间换时间的思路。优化器采用采样评估出现误差的原因也在于，索引的标记删除影响的。</p>
<p>3：mysql如何判断一个查询的扫描行数?</p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。我们可以使用 show index 方法，看到一个索引的基数。</p>
<p>4：索引基数如何计算?</p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p>
<p>5：可以重新统计索引信息的命令是什么?</p>
<p>analyze table t 命令，可以用来重新统计索引信息</p>
<p>6： 索引选择异常的问题可以有哪几种处理方式?</p>
<ol>
<li><p>强制指定使用某个索引，不常用不推荐用</p>
</li>
<li><p>调整SQL语句，使优化器选择的和我们想的一样，不具有通用性</p>
</li>
<li><p>新建更合适的索引或者删除不合适的索引，是一个思路</p>
</li>
<li><p>使用analyze table可以解决索引统计信息不准确导致的索引选错的问题</p>
</li>
</ol>
<h1 id="怎么给字符串字段加索引"><a href="#怎么给字符串字段加索引" class="headerlink" title="怎么给字符串字段加索引"></a>怎么给字符串字段加索引</h1><p>MySQL 是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<p>前缀索引使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正常默认索引-包含了每个记录的整个字符串</span><br><span class="line">alter table SUser add index index1(email);</span><br><span class="line"></span><br><span class="line"># 前缀索引-对于每个记录都是只取前 6 个字节</span><br><span class="line">alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure>

<h2 id="两种索引的数据结构和存储区别"><a href="#两种索引的数据结构和存储区别" class="headerlink" title="两种索引的数据结构和存储区别"></a>两种索引的数据结构和存储区别</h2><p>前缀索引因为只取整个字段的前几个字节，所以<strong>占用空间会更少</strong>，这就是使用前缀索引的优势，这同时带来的损失是，可能<strong>会增加额外的记录扫描次数</strong>，具体来说主要是使用索引检索的过程如下进行分析：</p>
<ol>
<li><p>如果我们用的是整个字符串的索引，首先我们直接根据索引定位要查询的字符串，然后回表，取出数据，然后检索对比下一条，发现不满足条件，就查询结束。</p>
</li>
<li><p>如果使用前缀索引，因为前缀相同的记录可能会有多条，这样的情况也很正常，它就需要每一条都扫描，然后回表去查询具体的数据来进行对比，一直找到前缀不能匹配的记录，所以这就是前缀索引会增加额外的扫描次数的原因。</p>
</li>
</ol>
<p>但是：如果我们通过分析业务，使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本（通过前缀就能很快的区分出大部分的数据）。</p>
<h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><p>如下一条查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email from SUser where email=&apos;zhangssxyz@xxx.com&apos;;</span><br></pre></td></tr></table></figure>

<p>如果我们直接使用普通索引（email），我们因为有覆盖索引的机理，所以一次就能返回所有的数据而不需要进行回表，但是如果我们使用了覆盖索引，每一次都需要回表判断email字段是不是对应的具体记录，这样就增加了回表的逻辑，而事实上，即使我们的前缀索引长度<strong>设置的足够长，能包含所有的字段长度，它还是需要回表进行判断，因为系统并不知道前缀索引的定义是否截断了完整的信息</strong>。</p>
<p><strong>综上所述：使用前缀索引就用不上覆盖索引对查询性能的优化了</strong></p>
<h2 id="前缀索引使用的其他方式"><a href="#前缀索引使用的其他方式" class="headerlink" title="前缀索引使用的其他方式"></a>前缀索引使用的其他方式</h2><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？要知道，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p>
<ul>
<li><p><strong>方式一：倒序存储：</strong>倒序存储就是针对一些前缀区别度不大，但是后缀区别比较大的字段类型，我们可以使用倒序存储来创建前缀索引。</p>
</li>
<li><p><strong>方式二：使用hash字段：</strong>你可以在表上再创建一个整数字段，来保存你所要的业务字段的校验码，同时在这个字段上创建校验码。</p>
</li>
</ul>
<p>使用倒序存储和使用 hash 字段这两种方法的异同点:</p>
<p>相同点是，都不支持范围查询</p>
<p>不同点：</p>
<ol>
<li><p>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</p>
</li>
<li><p>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</p>
</li>
<li><p>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>直接创建完整索引，这样可能比较占用空间；</p>
</li>
<li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p>
</li>
<li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p>
</li>
<li><p>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</p>
</li>
</ol>
<h1 id="为什么MySQL会“抖一下”"><a href="#为什么MySQL会“抖一下”" class="headerlink" title="为什么MySQL会“抖一下”"></a>为什么MySQL会“抖一下”</h1><p>抖一下：一条SQL语句正常执行的时候非常的快，但有时突然就会变得特别慢，而且很难复现，它不止是随机的，而且持续时间很短。</p>
<h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
<p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），在更新内存写完 redo log 后，就返回给客户端，本次更新成功（WAL）。</p>
<p>内存里的数据总是要找时间写入磁盘的，这个过程术语就是 flush。在这个 flush 操作执行之前，内存中的数据跟磁盘上的数据是不一致的，因为还没有将redo log中的记录刷新到磁盘上。</p>
<p>所以我们就能够想象，我们的MySQL突然抖一下，就是因为在刷脏页，平时执行很快的更新操作，其实就是写了内存和日志。</p>
<h2 id="数据库flush过程的触发点"><a href="#数据库flush过程的触发点" class="headerlink" title="数据库flush过程的触发点"></a>数据库flush过程的触发点</h2><ol>
<li><p>InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写（环形链表结构）。checkpoint 可不是随便往前修改一下位置就可以的。它需要将两个点之间的日志，对应的所有脏页都 flush 到磁盘上。</p>
</li>
<li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。为什么刷脏页一定会写盘，这是为了保证每个数据页只有两种状态：</p>
</li>
</ol>
<ul>
<li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li>
<li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。</li>
</ul>
<ol start="3">
<li><p>MySQL 认为系统“空闲”的时候。当然MySQL及时忙的时候，也会见缝插针的找时间，只要有机会就会刷一点脏页。</p>
</li>
<li><p>MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
</li>
</ol>
<h3 id="触发点的具体分析"><a href="#触发点的具体分析" class="headerlink" title="触发点的具体分析"></a>触发点的具体分析</h3><p>我们着重分析第一种和第二种情况，因为第三种和第四种都是正常的情况，我们不需要关注它的性能问题。</p>
<p>第一种是“redo log 写满了，要 flush 脏页”，这种情况是 InnoDB 要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。</p>
<p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>
<ol>
<li>第一种是，还没有使用的；</li>
<li>第二种是，使用了并且是干净页；</li>
<li>第三种是，使用了并且是脏页。</li>
</ol>
<p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ul>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li>
</ul>
<h2 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h2><ol>
<li><p>首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。这就要用到 <strong>innodb_io_capacity</strong> 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。<strong>因为没能正确地设置 innodb_io_capacity 参数，而导致的性能问题也比比皆是。</strong></p>
</li>
<li><p>innodb_flush_neighbors：MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。SSD的时代，建议设置为0，MySQL8 已经默认设置为0了。</p>
</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>WAL这个机制后续需要的刷脏页操作和执行时机。利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动 flush，也会由于数据页淘汰而触发 flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。</p>
<h3 id="重点的重点"><a href="#重点的重点" class="headerlink" title="重点的重点"></a>重点的重点</h3><p><strong>淘汰的时候，刷脏页过程不用动redo log文件的，直接将脏页数据刷到磁盘中就完成了。而在redo log重放的过程中，有个额外的保证，如果一个数据页已经是刷过的，会识别出来并跳过。这个保证的具体实现机制是：innodb的每个数据页头部有LSN，8字节，每次修改都会变大，对比这个LSN跟checkpoint 的LSN，比checkpoint小的一定是干净页。</strong><br>这样解决的问题是：当内存不够用了，要将脏页写到磁盘，会有一个数据页淘汰机制（最久不使用），假设淘汰的是脏页，则此时脏页所对应的redo log的位置是随机的，当有多个不同的脏页需要刷，则对应的redo log可能在不同的位置，这样就需要把redo log的多个不同位置刷掉，这样对于redo log的处理不是就会很麻烦（合并间隙，移动位置）</p>
<p>现在我们对 WAL、change buffer、脏页、flush串起来一下，首先我们来了一条更新数据的语句，如果此数据所在页已经在内存中，那么MySQL直接更新内存数据，然后写redo log，如果此数据页没有再内存中，那么MySQL会写change buffer（前提不是添加数据，或者修改的列没有建立唯一索引，如果建立了，就需要将数据页加载到内存中进行判断唯一，这样就直接更新内存了），然后写redo log，这样我们的更新就完成了。下面我们说flush的过程，1. 在我们内存满了后需要淘汰脏页，这是就会将脏页的数据在内存中直接刷到磁盘上，WAL进行redo log重放的时候，会判断此数据是否被之前已有脏页刷过盘了，如果刷过了就跳过，没有刷过就重放更新磁盘数据。2. change buffer中的数据加载是看数据有没有被读取过，如果数据被读取，那么数据就会从磁盘读取到内存中，然后从change buffer中取出更改更新到内存中，那么此时内存中就是脏页，脏页在淘汰或者刷盘中就走了正常逻辑，如果没有被读取，change buffer 的后台也会有自己的合并行为，在一定的时机就会将change buffer中的数据刷新到磁盘中（这里重点注意：如果change buffer中的数据被丢了，那么它还是可以通过 redo log 进行重放进行恢复）。3. redo log 的重放，重放会将我们所有的更改持久化到磁盘数据中，这里重放的时候会判断当前数据有没有被脏页刷盘过，有没有被change buffer的后台自动持久化过，如果有，就跳过，如果没有，就通过redo log进行重放（LSN）。</p>
<p><strong>redo log 的重放：</strong>redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p>
<ol>
<li><p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</p>
</li>
<li><p>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>
</li>
</ol>
<h1 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h1><p>一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小。</p>
<h2 id="参数-innodb-file-per-table"><a href="#参数-innodb-file-per-table" class="headerlink" title="参数 innodb_file_per_table"></a>参数 innodb_file_per_table</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p>
<ol>
<li><p>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p>
</li>
<li><p>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p>
</li>
</ol>
<p>建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<h2 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h2><p>InnoDB 里的数据都是用 B+ 树的结构组织的，假设我们有一个数据页PageA，数据页中存的数据ID有（3、5、6），现在我们把 ID为5 的这条记录删除，InnoDB 引擎只会把 5 这个记录标记为删除，如果之后要再插入一个 ID 在 3 和 6 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。如果我们删掉了一个数据页上的所有记录，那么整个数据页就可以被复用了，但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，比如上面这个例子，我们删除 5 记录之后，如果插入一个 ID 为8 的记录，就不能复用这个位置了。而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。</p>
<p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p>
<p>进一步地，<strong>如果我们用 delete 命令把整个表的数据删除，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</strong></p>
<h2 id="空洞"><a href="#空洞" class="headerlink" title="空洞"></a>空洞</h2><p>上述我们了解到，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<p><strong>插入数据也可以产生空洞：</strong>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。如果我们某个Page页满了，向此页中插入数据就不得不再申请一个新的数据页，来保存数据，页分裂完成后，旧页的末尾就留下了空洞。</p>
<p><strong>更新索引上的值也可以产生空洞：</strong>更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的（比如将一个索引的值 10 改为 1000）。</p>
<h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而重建表，就可以达到这样的目的。</p>
<p>可以使用 alter table A engine=InnoDB 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程大致是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。</span><br></pre></td></tr></table></figure>

<p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p>
<p><strong>MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</strong></p>
<h3 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h3><p>上述流程中，显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。在 MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。下面描述一下引入了 Online DDL 之后，重建表的流程：</p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<p>此过程与上述重建表过程不同的是，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p>
<h2 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h2><p>inplace：上述我们在讲MySQL 5.5 以前的版本重建表的流程，我们把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，是在 server 层创建的，而5.5之后，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p>
<p>inplace重建表的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace; (ALGORITHM=inplace 可以不加，因为它是默认的)</span><br></pre></td></tr></table></figure>

<p>copy重建表的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>

<p>当你使用 ALGORITHM=copy 的时候，表示的是强制拷贝表，对应的就是类似上述5.5版本重建表的逻辑流程。</p>
<h3 id="Online-和-inplace的区别"><a href="#Online-和-inplace的区别" class="headerlink" title="Online 和 inplace的区别"></a>Online 和 inplace的区别</h3><ol>
<li><p>DDL 过程如果是 Online 的，就一定是 inplace 的；</p>
</li>
<li><p>反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</p>
</li>
</ol>
<h3 id="optimize-table、analyze-table-和-alter-table-这三种方式重建表的区别"><a href="#optimize-table、analyze-table-和-alter-table-这三种方式重建表的区别" class="headerlink" title="optimize table、analyze table 和 alter table 这三种方式重建表的区别"></a>optimize table、analyze table 和 alter table 这三种方式重建表的区别</h3><ol>
<li><p>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是上面 Online重建表的 流程了；</p>
</li>
<li><p>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</p>
</li>
<li><p>optimize table t 等于 recreate+analyze。</p>
</li>
</ol>
<h1 id="count函数应用剖析"><a href="#count函数应用剖析" class="headerlink" title="count函数应用剖析"></a>count函数应用剖析</h1><h2 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h2><p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式：</p>
<ol>
<li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</p>
</li>
<li><p>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
</li>
</ol>
<p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。</p>
<p>为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？这是因为即使是在同一个时刻的多个查询，<strong>由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的</strong>。</p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>MyISAM 表虽然 count(*) 很快，但是不支持事务；</p>
</li>
<li><p>show table status 命令虽然返回很快，但是不准确；</p>
</li>
<li><p>InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。</p>
</li>
</ol>
<h2 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h2><p>count() 的语义：count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。所以，<strong>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</strong></p>
<ul>
<li><p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的（<strong>这里这个判断虽然是多余的，主键不可能为空，但是MySQL代码确实是这么做的</strong>），就按行累加。</p>
</li>
<li><p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
</ul>
<p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
<ul>
<li><strong>对于 count(字段) 来说：</strong></li>
</ul>
<ol>
<li><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</p>
</li>
<li><p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p>
</li>
</ol>
<ul>
<li><strong>对于 count(*) 来说</strong>：并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</li>
</ul>
<p>结论：按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以我建议你，尽量使用 count(\</em>)。</p>
<h1 id="order-by-的工作原理"><a href="#order-by-的工作原理" class="headerlink" title="order by 的工作原理"></a>order by 的工作原理</h1><p>这里用一条SQL语句举例说明： select city,name,age from t where city=’杭州’ order by name limit 1000; （city字段建立了索引）</p>
<h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p><strong>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</strong>。通常情况下，全字段排序上述语句执行流程如下：</p>
<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li>
<li>从索引 city 找到第一个满足 city=’杭州’ 条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止；</li>
<li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ol>
<p>排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序，外部排序一般使用归并排序算法。（一般是将数据分为多个小临时文件排好顺序，然后归并排序到一个大文件中）</p>
<h2 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h2><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>我们可以通过配置参数<strong>max_length_for_sort_data</strong>，控制用于排序的行数据的长度，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br></pre></td></tr></table></figure>

<p>city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16，新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id，这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回，具体执行流程如下：</p>
<ol>
<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>
<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到不满足 city=’杭州’条件为止；</li>
<li>对 sort_buffer 中的数据按照字段 name 进行排序；</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ol>
<p>对比全字段排序，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。</p>
<h2 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h2><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<h3 id="不用排序算法的-order-by-场景"><a href="#不用排序算法的-order-by-场景" class="headerlink" title="不用排序算法的 order by 场景"></a>不用排序算法的 order by 场景</h3><p>如果我们对上述查询语句的 city 和 name 建立联合索引，这时，对于 city 字段的值相同的行来说，还是按照 name 字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name) 取下一个记录主键 id；</li>
<li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li>
</ol>
<p>在我们这个例子里，只需要扫描 1000 次，不需要经历排序算法。</p>
<p>我们还可以建立(city,name,age)的联合索引，这样上述步骤中的的回表操作就可以完全省略，因为在索引中已经包含了我们需要的所有字段（<strong>覆盖索引的原理</strong>），这样性能会更快。</p>
<p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p>
<h3 id="explain-中-Extra-字段返回结果"><a href="#explain-中-Extra-字段返回结果" class="headerlink" title="explain 中 Extra 字段返回结果"></a>explain 中 Extra 字段返回结果</h3><p><strong>Using filesort：</strong>表示的就是需要排序</p>
<p><strong>Using temporary</strong>表示的是需要使用临时表</p>
<p>order by内部会使用归并排序，根据sort buffer size决定是否需要使用外部（磁盘）排序，根据max_length_for_sort_data决定使用全字段排序还是rowid排序，不同点是rowid排序，只使用排序字段和主键，会在原有的基础上，多进行回表查询，多了磁盘操作，为此可以使用复合查询，这样从索引中查询出来的数据，就是有序的，可以直接进行回表，返回result，也可以考虑是否使用覆盖索引，直接返回值，如果order by后面加上limit num，num是小值，在5.6以上会使用优先队列进行排序。</p>
<h2 id="rowid详解"><a href="#rowid详解" class="headerlink" title="rowid详解"></a>rowid详解</h2><p>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法回表了？其实不是的。</p>
<p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。这也就是排序模式里面，rowid 名字的来历。实际上它表示的是：</p>
<ol>
<li><p>每个引擎用来唯一标识数据行的信息。对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p>
</li>
<li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；</p>
</li>
<li><p>MEMORY 引擎不是索引组织表，你可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。</p>
</li>
</ol>
<p>本章节注意：内存临时表、磁盘临时表的概念</p>
<h1 id="SQL语句执行性能分析"><a href="#SQL语句执行性能分析" class="headerlink" title="SQL语句执行性能分析"></a>SQL语句执行性能分析</h1><h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>例如，对于一个查询语句，t_modified字段类型为datetime类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>

<p>上述语句就不会走索引，因为对索引字段做了month()函数操作</p>
<p>例如，<strong>对于 select * from tradelog where id + 1 = 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 where id = 10000 -1 才可以</strong>。</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>例如如下查询语句，tradeid 这个字段上建立了索引，字段类型是 varchar(32)，但是此语句却没有走索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>

<p>这里的原因就是，tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换，所以对于优化器来说，上述语句相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>

<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<p><strong>注意重点：当字符串和数字比较时会把字符串转化为数字</strong></p>
<h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>例如我们有如下查询语句，此两个表的tradeid 这个字段上都建立了索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;</span><br></pre></td></tr></table></figure>

<p>在这条语句中，tradelog 为驱动表，trade_detail为被驱动表，具体的查询逻辑如下：</p>
<ol>
<li>我们首先通过tradelog驱动表的主键索引找到id = 2的记录；</li>
<li>然后找出tradeid字段的值；</li>
<li>然后根据 tradeid 值到 trade_detail 表中查找条件匹配的行。</li>
</ol>
<p>这里我们通过explain结果集发现，trade_detail 的 tradeid 值匹配并没有走索引，这是因为：这两个表的字符集不同，一个是 utf8mb4，一个是 utf8，所以做表连接查询的时候用不上关联字段的索引。所以我们在做上述第三步的时候，具体查询逻辑类似如下SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where tradeid=$L2.tradeid.value;</span><br><span class="line">也就是：</span><br><span class="line">select * from trade_detail where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>$L2.tradeid.value 的字符集是 utf8mb,。字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p>
<p><strong>这个设定很好理解，utf8mb4 是 utf8 的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</strong></p>
<p>所以优化此查询语句，就可以修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2;</span><br></pre></td></tr></table></figure>

<p>这里，我主动把 l.tradeid 转成 utf8，就避免了被驱动表上的字符编码转换，从 explain 结果可以看到，这次索引走对了。</p>
<h2 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h2><p>索引字段不能进行函数操作，但是索引字段的参数可以玩函数，一言以蔽之。</p>
<h1 id="SQL语句执行慢分析"><a href="#SQL语句执行慢分析" class="headerlink" title="SQL语句执行慢分析"></a>SQL语句执行慢分析</h1><h2 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h2><h3 id="等-MDL-锁"><a href="#等-MDL-锁" class="headerlink" title="等 MDL 锁"></a>等 MDL 锁</h3><p>例如我们执行一条很简单的语句：select * from t where id=1; 结果长时间不返回，一般出现这种情况大概率是表被锁住了，分析时我们一般执行 <strong>show processlist</strong> 命令，查看当前语句处于什么状态。</p>
<p>使用 show processlist 命令查看语句出现 Waiting for table metadata lock 的状态，说明现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了。场景是:session A 通过 lock table 命令持有表 t 的 MDL 写锁，而 session B 的查询需要获取 MDL 读锁。所以，session B 进入等待状态。这类问题的处理方式，就是找到谁持有 MDL 写锁，然后把它 kill 掉。(通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。)</p>
<h3 id="等-flush"><a href="#等-flush" class="headerlink" title="等 flush"></a>等 flush</h3><p>我们使用select * from information_schema.processlist查询结果，发现状态有 Waiting for table flush，这个状态表示的是，现在有一个线程正要对表 t 做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>
<ol>
<li><p>flush tables t with read lock;</p>
</li>
<li><p>flush tables with read lock;</p>
</li>
</ol>
<p>这两个 flush 语句，如果指定表 t 的话，代表的是只关闭表 t；如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。所以，出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句，这个别的语句可能是一个耗时很长的查询操作，或者耗时很长的更新操作。</p>
<h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><p>例如：一条更新语句占用了写锁，并且事务一直没有提交，另一条查询语句如下 select * from t where id=1 lock in share mode; 或是使用了for update都表示需要当前读，这样就需要给当前数据加写锁，这时因为上一条执行事务没有提交，锁一直没有释放，就导致本条查询语句一直被阻塞。</p>
<p>我们可以通过SQL语句查看具体是被什么被锁住了：<strong>select * from t sys.innodb_lock_waits where locked_table=’[schema.tablename]’</strong>。查找到 blocking_pid，然后 kill [pid] 即可完成释放。</p>
<h2 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h2><h3 id="扫描行数多"><a href="#扫描行数多" class="headerlink" title="扫描行数多"></a>扫描行数多</h3><p>例如有如下语句：select * from t where c=50000 limit 1; 这条语句慢是因为字段c上没有索引，所以只能走主键ID顺序扫描，然后取出行记录进行对比，因此需要扫描50000行。<strong>扫描行数越多，执行越慢</strong></p>
<h3 id="一致性读-undo-log-回放"><a href="#一致性读-undo-log-回放" class="headerlink" title="一致性读 undo log 回放"></a>一致性读 undo log 回放</h3><p>比如我们会遇到一种现象，执行SQL语句 select * from t where id=1； 这条SQL只扫描一行，但是执行时间确很长，如果我们执行语句是 select * from t where id=1 lock in share mode，执行时扫描行数也是 1 行，执行时间确非常短，看上去非常奇怪，按理说 lock in share mode 还要加锁，时间应该更长才对啊，具体说明如下，如下SQL流程：</p>
<table>
<thead>
<tr>
<th align="center">session A</th>
<th align="center">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start transaction with consistent snapshot;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update t set c = c + 1 where id = 1;// 执行100万次</td>
</tr>
<tr>
<td align="center">select * from t where id = 1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from t where id = 1 lock in share mode;</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>你看到了，session A 先用 start transaction with consistent snapshot 命令启动了一个事务，之后 session B 才开始执行 update 语句，session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)。带 lock in share mode 的 SQL 语句，是当前读，因此会直接读到 1000001 这个结果，所以速度很快；而 select * from t where id=1 这个语句，是一致性读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。所以这就是上述现象的原因。</p>
<h1 id="幻读和间隙锁"><a href="#幻读和间隙锁" class="headerlink" title="幻读和间隙锁"></a>幻读和间隙锁</h1><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>什么是幻读？</p>
<ol>
<li><p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p>
</li>
<li><p>上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</p>
</li>
</ol>
<p>幻读带来的问题？</p>
<ol>
<li>对行锁语义的破坏</li>
<li>破坏了数据一致性</li>
</ol>
<p>为啥会出现幻读？</p>
<p>行锁只能锁定存在的行，针对新插入的操作没有限定</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。</p>
<p>注意：间隙锁是在可重复读隔离级别（RR）下才会生效的。</p>
<p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</strong></p>
<p><strong>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。</strong>也就是说，我们有一个表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 next-key lock，分别是 (-∞, id1]、(id2, id3]、… 、(idn, +supremum]。supremum从哪儿来的呢？这是因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合我们前面说的“都是前开后闭区间”。</p>
<p><strong>注意：间隙锁本身是前开后开的区间锁，next-key lock 才是前开后闭区间。</strong></p>
<p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</strong></p>
<h2 id="非索引字段update或者delete"><a href="#非索引字段update或者delete" class="headerlink" title="非索引字段update或者delete"></a>非索引字段update或者delete</h2><p>对于非索引字段进行update或select .. for update操作，代价极高。所有记录上锁，以及所有间隔的锁。对于索引字段进行上述操作，代价一般。只有索引字段本身和附近的间隔会被加锁。<br>（个人理解：锁是加在主键索引上的）</p>
<h1 id="MySQL加锁规则"><a href="#MySQL加锁规则" class="headerlink" title="MySQL加锁规则"></a>MySQL加锁规则</h1><p>MySQL加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</p>
<ol>
<li><p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
</li>
<li><p>原则 2：查找过程中访问到的对象才会加锁。</p>
</li>
<li><p>优化 1：索引上的<strong>等值查询</strong>，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
</li>
<li><p>优化 2：索引上的<strong>等值查询</strong>，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
</li>
<li><p>一个 bug：<strong>唯一索引上的范围查询</strong>会访问到不满足条件的第一个值为止。</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li><p>只有访问到的对象才会加锁，比如我们访问一个普通索引的字段，使用覆盖索引就可以查询出来数据，这时我们是不会给主键索引来加锁的。（lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。）</p>
</li>
<li><p>申请锁的顺序是 先申请间隙锁，然后再申请行锁。（有的时候我们一条更新语句加锁的时候我们先加了间隙锁，然后加行锁的时候发现行被占用，因为间隙锁之间不是互斥的，这是行锁申请失败被阻塞住等待其他事务释放行锁，但间隙锁已经加成功，也会导致一些其他的操作被此间隙锁所阻塞住）。</p>
</li>
<li><p>在删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
</li>
<li><p>“有行”才会加行锁。如果查询条件没有命中行，那就加 next-key lock。</p>
</li>
<li><p>范围查询：无论是否是唯一索引，范围查询都需要访问到不满足条件的第一个值为止。</p>
</li>
<li><p>例如有一个表有数据如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>对应字段为(id, c, d)，c 建立了普通索引</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>我们有如下查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">select * from t where t.c &gt;= 15 and c &lt; 20 order by c desc lock in share mode;</span><br></pre></td></tr></table></figure>

<p>这里的加锁逻辑如下:</p>
<ol>
<li>由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</li>
<li>在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]。 注意这里是重点：<strong>为什么会加(5,10]，因为我们的desc向左扫描的时候，我们需要扫描到10才能停下来，而我们的 next-key lock 是前开后闭区间，为了保证10这行本身也被锁住，所以我们需要正向的加 (5,10] 的 next-key lock，所以这就是为什么这个锁的范围这么广的原因。而如果我们是asc，这样就不会存在这种问题，就是正常的加锁逻辑，不会多出来一个锁区间。</strong></li>
<li>在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁。</li>
</ol>
<p><strong>先定位索引c上最右边c=20的行，所以第一个等值查询会扫描到c=25，然后通过优化2，next-key lock退化为间隙锁，则会加上间隙锁（20，25），紧接着再向左遍历，会加 next-key lock (15, 20], (10, 15], 因为要扫描到c=10才停下来，所以也会加next-key lock (5,10]</strong></p>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>如上数据库表结构还有经典加锁示例如下语句：</p>
<p>sessionA:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where  c &gt; 5 lock in share mode;</span><br></pre></td></tr></table></figure>

<p>sessionB:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update t set c = 1 where c = 5;</span><br><span class="line">(Query OK)</span><br><span class="line">update t set c = 5 where c = 1;</span><br><span class="line">(blocked)</span><br></pre></td></tr></table></figure>

<p>上述语句同时执行，sessionB的第二条语句会被阻塞住。原因是：首先sessionA的加锁范围是:</p>
<p>索引 c 上的 (5,10]、(10,15]、(15,20]、(20,25]和 (25,supremum]。 注意：根据 c&gt;5 查到的第一个记录是 c=10，因此不会加 (0,5]这个 next-key lock。</p>
<p>之后 session B 的第一个 update 语句，要把 c=5 改成 c=1，你可以理解为两步：</p>
<ol>
<li><p>插入 (c=1, id=5) 这个记录；</p>
</li>
<li><p>删除 (c=5, id=5) 这个记录。</p>
</li>
</ol>
<p>索引 c 上 (5,10) 间隙是由这个间隙右边的记录，也就是 c=10 定义的。所以通过这个操作，session A 的加锁范围变成了 (1,10]、(10,15] …</p>
<p>接下来 session B 要执行 update t set c = 5 where c = 1 这个语句了，一样地可以拆成两步：</p>
<ol>
<li><p>插入 (c=5, id=5) 这个记录；</p>
</li>
<li><p>删除 (c=1, id=5) 这个记录。</p>
</li>
</ol>
<p>第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</p>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>如上数据库表结构还有经典加锁示例如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure>

<p>这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和 (10, 15)。也就是说，id=15 这一行，并没有被加上行锁。为什么呢？</p>
<p>当试图去找 “第一个id &lt; 12的值”的时候，用的还是从左往右的遍历（因为用到了优化2），也就是说，当去<strong>找第一个等值的时候</strong>（通过树搜索去定位记录的时候），即使order by desc，但用的还是向右遍历，当找到了第一个等值的时候（例子中的id=15），然后根据order by desc，再向左遍历。</p>
<h1 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h1><ol>
<li>为什么没有意向锁的话，表锁和行锁不能共存？</li>
</ol>
<p>举个粟子（此时假设行锁和表锁能共存）： 事务A锁住表中的一行（写锁）。事务B锁住整个表（写锁）。</p>
<p>但你就会发现一个很明显的问题，事务A既然锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！</p>
<ol start="2">
<li>意向锁是如何让表锁和行锁共存的？</li>
</ol>
<p>有了意向锁之后，前面例子中的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。</p>
<p>所以，意向锁的作用就是：</p>
<p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。</p>
<ol start="3">
<li>意向锁是表锁还是行锁？</li>
</ol>
<p>首先可以肯定的是，意向锁是表级别锁。意向锁是表锁是有原因的。</p>
<p>当我们需要给一个加表锁的时候，我们需要根据意向锁去判断表中有没有数据行被锁定，以确定是否能加成功。如果意向锁是行锁，那么我们就得遍历表中所有数据行来判断。如果意向锁是表锁，则我们直接判断一次就知道表中是否有数据行被锁定了。</p>
<p>注：意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。 </p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年11月26日 17:11</p>
        <p>原始链接： <a class="post-url" href="/2020/07/12/MySQL-实践一/" title="MySQL-实践一">https://jjw-story.github.io/2020/07/12/MySQL-实践一/</a></p>
        <footer>
            <a href="https://jjw-story.github.io">
                <img src="/images/logo.png" alt="JJW">
                JJW
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://jjw-story.github.io/2020/07/12/MySQL-实践一/&title=《MySQL-实践一》 — JJW-STORY&pic=/images/blogs/mysql.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://jjw-story.github.io/2020/07/12/MySQL-实践一/&title=《MySQL-实践一》 — JJW-STORY&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://jjw-story.github.io/2020/07/12/MySQL-实践一/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MySQL-实践一》 — JJW-STORY&url=https://jjw-story.github.io/2020/07/12/MySQL-实践一/&via=https://jjw-story.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://jjw-story.github.io/2020/07/12/MySQL-实践一/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://jjw-story.github.io/2020/07/12/MySQL-实践一/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/MySQL/" class="color1">MySQL</a>
      
    <a href="/tags/实践一/" class="color4">实践一</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#普通索引和唯一索引的选择"><span class="post-toc-text">普通索引和唯一索引的选择</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#普通索引和唯一索引的查询过程对比"><span class="post-toc-text">普通索引和唯一索引的查询过程对比</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#普通索引和唯一索引的更新过程对比"><span class="post-toc-text">普通索引和唯一索引的更新过程对比</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#change-buffer"><span class="post-toc-text">change buffer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#唯一索引和普通索引对于change-buffer的应用特点对比"><span class="post-toc-text">唯一索引和普通索引对于change buffer的应用特点对比</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#change-buffer-的使用场景"><span class="post-toc-text">change buffer 的使用场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#change-buffer-和-redo-log"><span class="post-toc-text">change buffer 和 redo log</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#MySQL为什么有时候会选错索引"><span class="post-toc-text">MySQL为什么有时候会选错索引</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#怎么给字符串字段加索引"><span class="post-toc-text">怎么给字符串字段加索引</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#两种索引的数据结构和存储区别"><span class="post-toc-text">两种索引的数据结构和存储区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前缀索引对覆盖索引的影响"><span class="post-toc-text">前缀索引对覆盖索引的影响</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前缀索引使用的其他方式"><span class="post-toc-text">前缀索引使用的其他方式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#为什么MySQL会“抖一下”"><span class="post-toc-text">为什么MySQL会“抖一下”</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#脏页"><span class="post-toc-text">脏页</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据库flush过程的触发点"><span class="post-toc-text">数据库flush过程的触发点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#触发点的具体分析"><span class="post-toc-text">触发点的具体分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#InnoDB-刷脏页的控制策略"><span class="post-toc-text">InnoDB 刷脏页的控制策略</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结-1"><span class="post-toc-text">总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重点的重点"><span class="post-toc-text">重点的重点</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数据库表的空间回收"><span class="post-toc-text">数据库表的空间回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参数-innodb-file-per-table"><span class="post-toc-text">参数 innodb_file_per_table</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据删除流程"><span class="post-toc-text">数据删除流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#空洞"><span class="post-toc-text">空洞</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#重建表"><span class="post-toc-text">重建表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Online-DDL"><span class="post-toc-text">Online DDL</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Online-和-inplace"><span class="post-toc-text">Online 和 inplace</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Online-和-inplace的区别"><span class="post-toc-text">Online 和 inplace的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#optimize-table、analyze-table-和-alter-table-这三种方式重建表的区别"><span class="post-toc-text">optimize table、analyze table 和 alter table 这三种方式重建表的区别</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#count函数应用剖析"><span class="post-toc-text">count函数应用剖析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#count-的实现方式"><span class="post-toc-text">count(*) 的实现方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#小结"><span class="post-toc-text">小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#不同的-count-用法"><span class="post-toc-text">不同的 count 用法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#order-by-的工作原理"><span class="post-toc-text">order by 的工作原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#全字段排序"><span class="post-toc-text">全字段排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rowid-排序"><span class="post-toc-text">rowid 排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#全字段排序-VS-rowid-排序"><span class="post-toc-text">全字段排序 VS rowid 排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不用排序算法的-order-by-场景"><span class="post-toc-text">不用排序算法的 order by 场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#explain-中-Extra-字段返回结果"><span class="post-toc-text">explain 中 Extra 字段返回结果</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rowid详解"><span class="post-toc-text">rowid详解</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SQL语句执行性能分析"><span class="post-toc-text">SQL语句执行性能分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#条件字段函数操作"><span class="post-toc-text">条件字段函数操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#隐式类型转换"><span class="post-toc-text">隐式类型转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#隐式字符编码转换"><span class="post-toc-text">隐式字符编码转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#本节总结"><span class="post-toc-text">本节总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SQL语句执行慢分析"><span class="post-toc-text">SQL语句执行慢分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查询长时间不返回"><span class="post-toc-text">查询长时间不返回</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#等-MDL-锁"><span class="post-toc-text">等 MDL 锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#等-flush"><span class="post-toc-text">等 flush</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#等行锁"><span class="post-toc-text">等行锁</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查询慢"><span class="post-toc-text">查询慢</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扫描行数多"><span class="post-toc-text">扫描行数多</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一致性读-undo-log-回放"><span class="post-toc-text">一致性读 undo log 回放</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#幻读和间隙锁"><span class="post-toc-text">幻读和间隙锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#幻读"><span class="post-toc-text">幻读</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#间隙锁"><span class="post-toc-text">间隙锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#非索引字段update或者delete"><span class="post-toc-text">非索引字段update或者delete</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#MySQL加锁规则"><span class="post-toc-text">MySQL加锁规则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#示例一"><span class="post-toc-text">示例一</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#示例二"><span class="post-toc-text">示例二</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#示例三"><span class="post-toc-text">示例三</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#意向锁"><span class="post-toc-text">意向锁</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/07/20/Spark-入门/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Spark-入门
        
      </span>
    </a>
  
  
    <a href="/2020/07/10/MySQL-基础/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">MySQL-基础</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 JJW<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://jjw-story.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Flink/">Flink</a><a class="category-link" href="/categories/IDEA/">IDEA</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/Lamda/">Lamda</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/MQ/">MQ</a><a class="category-link" href="/categories/MySQL/">MySQL</a><a class="category-link" href="/categories/Python/">Python</a><a class="category-link" href="/categories/Scala/">Scala</a><a class="category-link" href="/categories/Spark/">Spark</a><a class="category-link" href="/categories/设计模式/">设计模式</a><a class="category-link" href="/categories/高效员工起航训练营/">高效员工起航训练营</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Compose/" style="font-size: 10px;">Compose</a> <a href="/tags/Design/" style="font-size: 13.33px;">Design</a> <a href="/tags/Django/" style="font-size: 13.33px;">Django</a> <a href="/tags/Docker/" style="font-size: 18.33px;">Docker</a> <a href="/tags/Elasticsearch核心技术/" style="font-size: 10px;">Elasticsearch核心技术</a> <a href="/tags/Flink/" style="font-size: 13.33px;">Flink</a> <a href="/tags/Flink-Storm-SparkStream对比/" style="font-size: 10px;">Flink Storm SparkStream对比</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Kebernetes/" style="font-size: 10px;">Kebernetes</a> <a href="/tags/Kubernetes/" style="font-size: 10px;">Kubernetes</a> <a href="/tags/Lamda/" style="font-size: 10px;">Lamda</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Python基础/" style="font-size: 10px;">Python基础</a> <a href="/tags/Scala/" style="font-size: 11.67px;">Scala</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Swarm/" style="font-size: 10px;">Swarm</a> <a href="/tags/command/" style="font-size: 20px;">command</a> <a href="/tags/overview/" style="font-size: 10px;">overview</a> <a href="/tags/su-sudo/" style="font-size: 10px;">su-sudo</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/入门/" style="font-size: 16.67px;">入门</a> <a href="/tags/内存与磁盘管理/" style="font-size: 10px;">内存与磁盘管理</a> <a href="/tags/创建型设计模式/" style="font-size: 10px;">创建型设计模式</a> <a href="/tags/原则-规范-重构/" style="font-size: 10px;">原则-规范-重构</a> <a href="/tags/基础入门/" style="font-size: 10px;">基础入门</a> <a href="/tags/实践一/" style="font-size: 10px;">实践一</a> <a href="/tags/实践三/" style="font-size: 10px;">实践三</a> <a href="/tags/实践二/" style="font-size: 10px;">实践二</a> <a href="/tags/帮助命令/" style="font-size: 10px;">帮助命令</a> <a href="/tags/打包压缩与解压缩/" style="font-size: 10px;">打包压缩与解压缩</a> <a href="/tags/数据持久化/" style="font-size: 10px;">数据持久化</a> <a href="/tags/文件及目录权限/" style="font-size: 10px;">文件及目录权限</a> <a href="/tags/文件查看命令/" style="font-size: 10px;">文件查看命令</a> <a href="/tags/文件管理命令/" style="font-size: 10px;">文件管理命令</a> <a href="/tags/文本查看命令/" style="font-size: 10px;">文本查看命令</a> <a href="/tags/用户和权限管理/" style="font-size: 10px;">用户和权限管理</a> <a href="/tags/结构型设计模式/" style="font-size: 10px;">结构型设计模式</a> <a href="/tags/网络管理/" style="font-size: 15px;">网络管理</a> <a href="/tags/语法/" style="font-size: 10px;">语法</a> <a href="/tags/软件包管理器和内核升级/" style="font-size: 10px;">软件包管理器和内核升级</a> <a href="/tags/运行时架构/" style="font-size: 10px;">运行时架构</a> <a href="/tags/进程管理/" style="font-size: 10px;">进程管理</a> <a href="/tags/进阶/" style="font-size: 10px;">进阶</a> <a href="/tags/逻辑卷管理/" style="font-size: 10px;">逻辑卷管理</a> <a href="/tags/镜像的构建和发布及容器操作/" style="font-size: 10px;">镜像的构建和发布及容器操作</a> <a href="/tags/高效员工起航训练营/" style="font-size: 10px;">高效员工起航训练营</a> <a href="/tags/高阶/" style="font-size: 10px;">高阶</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Compose/" style="font-size: 10px;">Compose</a> <a href="/tags/Design/" style="font-size: 13.33px;">Design</a> <a href="/tags/Django/" style="font-size: 13.33px;">Django</a> <a href="/tags/Docker/" style="font-size: 18.33px;">Docker</a> <a href="/tags/Elasticsearch核心技术/" style="font-size: 10px;">Elasticsearch核心技术</a> <a href="/tags/Flink/" style="font-size: 13.33px;">Flink</a> <a href="/tags/Flink-Storm-SparkStream对比/" style="font-size: 10px;">Flink Storm SparkStream对比</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Kebernetes/" style="font-size: 10px;">Kebernetes</a> <a href="/tags/Kubernetes/" style="font-size: 10px;">Kubernetes</a> <a href="/tags/Lamda/" style="font-size: 10px;">Lamda</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Python基础/" style="font-size: 10px;">Python基础</a> <a href="/tags/Scala/" style="font-size: 11.67px;">Scala</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Swarm/" style="font-size: 10px;">Swarm</a> <a href="/tags/command/" style="font-size: 20px;">command</a> <a href="/tags/overview/" style="font-size: 10px;">overview</a> <a href="/tags/su-sudo/" style="font-size: 10px;">su-sudo</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/入门/" style="font-size: 16.67px;">入门</a> <a href="/tags/内存与磁盘管理/" style="font-size: 10px;">内存与磁盘管理</a> <a href="/tags/创建型设计模式/" style="font-size: 10px;">创建型设计模式</a> <a href="/tags/原则-规范-重构/" style="font-size: 10px;">原则-规范-重构</a> <a href="/tags/基础入门/" style="font-size: 10px;">基础入门</a> <a href="/tags/实践一/" style="font-size: 10px;">实践一</a> <a href="/tags/实践三/" style="font-size: 10px;">实践三</a> <a href="/tags/实践二/" style="font-size: 10px;">实践二</a> <a href="/tags/帮助命令/" style="font-size: 10px;">帮助命令</a> <a href="/tags/打包压缩与解压缩/" style="font-size: 10px;">打包压缩与解压缩</a> <a href="/tags/数据持久化/" style="font-size: 10px;">数据持久化</a> <a href="/tags/文件及目录权限/" style="font-size: 10px;">文件及目录权限</a> <a href="/tags/文件查看命令/" style="font-size: 10px;">文件查看命令</a> <a href="/tags/文件管理命令/" style="font-size: 10px;">文件管理命令</a> <a href="/tags/文本查看命令/" style="font-size: 10px;">文本查看命令</a> <a href="/tags/用户和权限管理/" style="font-size: 10px;">用户和权限管理</a> <a href="/tags/结构型设计模式/" style="font-size: 10px;">结构型设计模式</a> <a href="/tags/网络管理/" style="font-size: 15px;">网络管理</a> <a href="/tags/语法/" style="font-size: 10px;">语法</a> <a href="/tags/软件包管理器和内核升级/" style="font-size: 10px;">软件包管理器和内核升级</a> <a href="/tags/运行时架构/" style="font-size: 10px;">运行时架构</a> <a href="/tags/进程管理/" style="font-size: 10px;">进程管理</a> <a href="/tags/进阶/" style="font-size: 10px;">进阶</a> <a href="/tags/逻辑卷管理/" style="font-size: 10px;">逻辑卷管理</a> <a href="/tags/镜像的构建和发布及容器操作/" style="font-size: 10px;">镜像的构建和发布及容器操作</a> <a href="/tags/高效员工起航训练营/" style="font-size: 10px;">高效员工起航训练营</a> <a href="/tags/高阶/" style="font-size: 10px;">高阶</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>