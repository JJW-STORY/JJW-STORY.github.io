{"meta":{"title":"JJW-STORY","subtitle":null,"description":null,"author":"JJW","url":"https://jjw-story.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-06T09:23:47.544Z","updated":"2019-07-06T09:23:47.544Z","comments":true,"path":"about/index.html","permalink":"https://jjw-story.github.io/about/index.html","excerpt":"","text":"关于我北京车和家信息技术有限公司~~开发工程师 关于工作城市：北京 关于学习每天都走在学习的大路上 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好杂乱无章 联系我 Home: JJW-STORE.GITHUB.IO Blog: JJW-STORE.GITHUB.IO Email: CHINAGOLDWJ@163.COM GitHub: JJW-STORE WeiBo: JJWStrive"}],"posts":[{"title":"用户和权限管理","slug":"用户和用户组管理","date":"2019-07-25T12:00:00.000Z","updated":"2019-07-27T06:08:31.650Z","comments":true,"path":"2019/07/25/用户和用户组管理/","link":"","permalink":"https://jjw-story.github.io/2019/07/25/用户和用户组管理/","excerpt":"","text":"用户管理Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个惟一的用户名和各自的口令，用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改 用户口令的管理 用户组的管理 用户管理常用命令当前使用的Linux系统中已经有了两个用户，一个是root用户，一个是自己创建的用户，root用户是超级管理员，我们自己创建的用户是普通用户。LInux多用户其实就是将用户分成了两类用户，一类是root用户，一类是普通用户 root用户的权限比较大，它可以访问自己的家目录，访问系统的配置文件，例如之前我们修改的vim的配置文件，还有就是root用户还可以访问普通用户的家目录，但是普通用户的权限就受到了下去限制，它只能访问自己的家目录，以及root用户开放给它的一些没有危害到系统安全的目录文件 普通用户和普通用户之间是没有权限互相访问他们对方的家目录的，Linux就是通过这两种用户的区别，来做了最基本的权限隔离 用户添加命令用户添加命令实际使用的是 useradd命令，使用方法：useradd [选项] 用户名称 在添加用户完成后，我们可以使用 id 命令来验证是否添加成功，通过 id 命令，我们可以查看系统中有哪些已经存在的用户 1234567root@CHJ-20190520VPS:/# useradd wangjiasroot@CHJ-20190520VPS:/# id rootuid=0(root) gid=0(root) groups=0(root)root@CHJ-20190520VPS:/# id wangjiasuid=1001(wangjias) gid=1001(wangjias) groups=1001(wangjias)root@CHJ-20190520VPS:/# id abcid: ‘abc’: no such user 下面分析我们添加用户的时候Linux都做了哪些操作： 首先第一是为新添加的用户创建了它的家目录，创建完成我们访问的时候发现家目录是空的，但其实用户的家目录是存放了很多与用户相关的隐藏配置文件 第二步就是将我们创建的用户记录在 /etc/passwd 文件中，只要包含了如下所示内容，就说明我们系统中存在这样的一个用户 123root@CHJ-20190520VPS:/# cat /etc/passwd...wangjias:x:1001:1001::/home/wangjias:/bin/sh 第三步还会在 etc/shadow 文件中添加我们创建的用户信息，这个文件是用户密码相关的文件 还有就是我们每创建一个用户，都会创建一个独立的用户id，叫uid，如上述我们通过id命令查询出来的内容。注意root用户的id是0，如果我们把普通用户的id也修改为0，那么系统就会把此用户也当成root用户 第四就是还会为用户创建用户所属的组，如果我们没有明确指定所属的组，系统就会创建一个与用户同名的组作为新创建用户所属的组。如果我们希望有一组用户他们使用同样的资源的时候，就可以建立一个这样的用户组，然后把他们都加入到这个组里面，如果我们对这个组进行修改，就相当于对一组的用户全都进行修改 注意创建用户只有root用户有这样的权限，普通用户没有创建用户的权限 上面的创建我们没有指定选项，下面介绍一些选项： -c comment 指定一段注释性描述 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g 用户组 指定用户所属的用户组 -G 用户组，用户组 指定用户所属的附加组 -s Shell文件 指定用户的登录Shell -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 为用户设置密码用户登录是需要登录密码的，为用户设置密码的命令使用的是 passwd命令，使用方法：passwd [用户名] 注意用户名选项是可选的，如果不指定要修改密码的用户名，那就是修改当前用户的密码 1234root@CHJ-20190520VPS:/# passwd wangjiasEnter new UNIX password:Retype new UNIX password:passwd: password updated successfully 删除用户删除用户使用的是userdel命令，使用方法： userdel [选项] 用户名 注意我们一般删除用户的时候会添加上 “-r” 选项，如果我们直接使用用户删除命令删除用户，则此用户的家目录会被保留下来，当我们确认用户的家目录中的数据都可以被直接删除的时候，就可以添加 -r 这个选项，直接删除彻底。 如果执行的是彻底删除的命令，那么 /etc/passed 和 /etc/shadow 中的用户信息也会被删除 修改账号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，使用方法：usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值 经常使用的选项是 -d 选项，既指定用户新的家目录，使用方法：usermod -d 新的家目录 用户名 如果我们修改了用户的家目录，那么我们重新登录此用户的时候，它的默认目录就会成为我们修改的目录，并且关于此用户的配置文件也会放在新的家目录中 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新 用户组管理命令新建用户组新建用户组使用groupadd命令，使用方法：groupadd [选项] 用户组 选项一般使用 -g 选项，此选项用于指定用户组的组标识号 新建好组之后，有两种方式将用户添加至先建好的组，第一种是使用 usermod 命令： 12345root@CHJ-20190520VPS:/# groupadd -g 1001 group1root@CHJ-20190520VPS:/# useradd user1root@CHJ-20190520VPS:/# usermod -g group1 user1root@CHJ-20190520VPS:/# id user1uid=1001(user1) gid=1001(group1) groups=1001(group1) 可以看到我们已经将user1用户添加到了group1组中 第二种就是在新建用户的时候直接将用户添加至指定用户组中: 123root@CHJ-20190520VPS:/# useradd -g group1 user2root@CHJ-20190520VPS:/# id user2uid=1002(user2) gid=1001(group1) groups=1001(group1 修改用户组修改用户组的属性使用groupmod命令，使用方法：groupmod [选项] 用户组 常用选项如下： -g GID 为用户组指定新的组标识号 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同 -n 新用户组 将用户组的名字改为新名字 使用示例： 123root@CHJ-20190520VPS:/# groupmod -n group2 group1root@CHJ-20190520VPS:/# id user2uid=1002(user2) gid=1001(group2) groups=1001(group2) 删除用户组如果要删除一个已有的用户组，使用groupdel命令，使用方法：groupdel 用户组 1root@CHJ-20190520VPS:/# groupdel group2 用户和用户组配置文件用户和用户组相关的配置文件主要有三个，/etc/passwd、/ect/shadow、/etc/group passwd文件内容如下： 12345671 root:x:0:0:root:/root:/bin/bash2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin3 bin:x:2:2:bin:/bin:/usr/sbin/nologin4 sys:x:3:3:sys:/dev:/usr/sbin/nologin...30 wangjia3:x:1000:1000:,,,:/home/wangjia3:/bin/bash31 user01:x:1001:1001::/home/user01:/bin/sh 我们发现此文件被分成了七个字段，下面分别解释每个字段的含义： 用户名称字段，表示用户的名称，可以看到此文件最后的两行是我们之前新创建的用户 第二个字段表示此用户登录需要不需要密码验证，如果把这个 “x” 删除之后，我们发现登录用户将不需要验证 1234wangjia3@CHJ-20190520VPS:~$ su -l wangjia3Password:wangjia3@CHJ-20190520VPS:~$ su -l user01user01@CHJ-20190520VPS:/$ 第三个字段是用户的uid字段，Linux并不是通过用户的名称来识别用户的，它是通过用户的id来识别用户，如果id重复了就会用最小id的用户使用 第四个字段是gid，是当前用户属于哪一个组的标识字段 第五个字段是注释 第六个字段表示用户的家目录的位置 用户登录后使用的命令解释器，现在所通用的命令解释器都是bash命令解释器。我们发现有很多第七个字段显示的是 /usr/sbin/nologin， 这里表示的是此用户是不能登录终端的，例如我们将user01用户的此字段修改为nologin： 123456 30 wangjia3:x:1000:1000:,,,:/home/wangjia3:/bin/bash 31 user01:x:1001:1001::/home/user01:/usr/sbin/nologinroot@CHJ-20190520VPS:~# su -l user01This account is currently not available.root@CHJ-20190520VPS:~# 切换用户失败，提示此账户不能登录 我们可以直接在这里添加一行数据，来添加用户 shadowshadow文件是保存用户和用户密码相关信息的，我们需要了解它的前两个字段 1234528 sshd:*:18037:0:99999:7:::29 pollinate:*:18037:0:99999:7:::30 wangjia3:$6$486gKZ88$cobO1oh/kuz4HwAmnpnb.OQtszzD78m0e.KvbbxcEbNfIA9/4cSKvU78iTMOgFL8FstKrk0hIQ/S16P/R5o6t.:18080:0: 99999:7:::31 user01:$6$Pe7lIEqi$28CGKQAIa3E4JvTvAZKeymjFgVY5HvGZXVg0RuUWetl2YTlgU5sLcMzRs6FZmJbnIvad3IeJO4bPXs082KqL10:18104:0:99 999:7::: 第一个字段是用户名称字段，用来和passwd字段来进行对应 是用户加密过的密码，加密的密码是以$开头，然后一串字符，这样主要是为了保护用户的密码，及时用户的密码是相同的，但是在此文件中的显示也是不同的，防止被破解 group和用户组相关的配置文件，里面包含四个字段： 第一个字段是组的名称 第二个字段这个组是否需要密码验证 第三个字段表示这个组的gid 第四个字段，表示其他组字段，表示哪些用户属于其他组，这个其他组里面又包含了用户名称","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"用户和权限管理","slug":"用户和权限管理","permalink":"https://jjw-story.github.io/tags/用户和权限管理/"}],"author":"JJW"},{"title":"Python","slug":"Python","date":"2019-07-20T12:00:00.000Z","updated":"2019-07-24T09:40:11.920Z","comments":true,"path":"2019/07/20/Python/","link":"","permalink":"https://jjw-story.github.io/2019/07/20/Python/","excerpt":"","text":"Python基础Python语法注释注释的三种方式如下： 123456789# 注释&apos;&apos;&apos;注释&apos;&apos;&apos;&quot;&quot;&quot;这也是注释&quot;&quot;&quot; 缩进python不需要 {} 都是使用缩进表示代码块 字符串字符串可以 ‘ ‘， “ “, “”” “”” 123456&apos;字符串&apos;&quot;字符串&quot;&quot;&quot;&quot;多行字符串&quot;&quot;&quot; 空行函数之间或类方法之间用空行分开 ; 符号同一行可以显示多条语句，使用 ; 隔开 导入 在 python 用 import 或者 from…import 来导入相应的模块 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * end关键字关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符 123while b &lt; 1000: print(b, end=&apos;,&apos;) b += 1 条件控制123456789101112if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句elif 表达式4: 语句else: 语句 循环while循环: 123456count = 0while count &lt; 5:print (count, &quot; 小于 5&quot;)count = count + 1else:print (count, &quot; 大于或等于 5&quot;) for循环： 12345678sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]for site in sites: if site == &quot;Runoob&quot;: print(&quot;菜鸟教程!&quot;) break print(&quot;循环数据 &quot; + site)else: print(&quot;没有循环数据!&quot;) 注意：以上循环中，else为跳出循环后执行的逻辑，且只执行一次，可以不存在else range()函数： 12345for i in range(103) : print(i)for i in range(0, 10, 3) : print(i) 参数最多可以有三个，第一个为开始限定，第二个为结束限定，第三个为步长 123a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]for i in range(len(a)): print(i, a[i]) break、continue break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环 pass 语句： 12while True: pass 遍历技巧： 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到： 1234567for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]): print(i, v)# 结果0 tic1 tac2 toe 反向遍历： 12for i in reversed(range(1, 10, 2)): print(i) 迭代器迭代器有两个基本的方法：iter( 和 next() 字符串，列表或元组对象都可用于创建迭代器 示例： 123456789101112list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=&quot; &quot;)list=[1,2,3,4]it = iter(list) # 创建迭代器对象while True: try: print (next(it)) except StopIteration: sys.exit() StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 函数1.语法12def 函数名（参数列表）: 函数体 可更改(mutable)与不可更改(immutable)对象： 不可变类型：变量赋值 a = 5 后再赋值 a = 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun(a)，传递的只是a的值，没有影响a对象本身。比如在 fun(a)内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后fun外部的la也会受影响 2.参数必需参数： 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，既只要声明了参数，调用时就必须传递 关键字参数：使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 例如： 1234567def printme( name, age ): &quot;打印任何传入的字符串&quot; print (str) return#调用printme函数printme( age = 10, name = &quot;菜鸟教程&quot;) 默认参数：调用函数时，如果没有传递参数，则会使用默认参数,与Kotlin一样 不定长参数：就是可变参数，python的可变参数可以有多种类型，任意指定 例如： 123456789# 可写函数说明def printinfo( arg1, **vardict ):&quot;打印任何传入的参数&quot;print (&quot;输出: &quot;)print (arg1)print (vardict)# 调用printinfo 函数printinfo(1, a=2,b=3) 3.匿名函数语法：lambda [arg1 [,arg2,…..argn]]:expression 示例： 12345# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print (&quot;相加后的值为 : &quot;, sum( 10, 20 )) 4.return语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式，不带参数值的return语句返回None 示例： 1234567def sum( arg1, arg2 ):total = arg1 + arg2print (&quot;函数内 : &quot;, total)return total# 调用sum函数total = sum( 10, 20 ) 变量作用域1.Python的作用域一共有4种 L： （Local） 局部作用域 E： （Enclosing） 闭包函数外的函数中 G： （Global） 全局作用域 B： （Built-in） 内置作用域（内置函数所在模块的范围） 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 示例： 12345g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 全局变量和局部变量，与Java类似 2.global 和 nonlocal 关键字当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字: 示例： 1234567891011num = 1 # 外部作用域定义变量def fun1(): global num # 需要使用 global 关键字声明 print(num) # 注意这两想要打印成功，一方面可思议使用global关键字，如果不适用此关键词声明，可以将num放在方法中传递进来使用，否则将会报错，这里跟Java不同，这是因为 fun1 函数中的 num 使用的是局部，未定义，无法修改。 num = 123 print(num)fun1() # 输出: 1 123print(num) # 输出： 123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字: 示例： 123456789def outer(): num = 10 # 嵌套作用域 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer() 输出 100 100 模块和包1.模块模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能，这也是使用 python 标准库的方法import 语句 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： import module1, module2,... moduleNfrom … import 语句 Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： from modname import name1, name2, ... nameNfrom … import * 语句 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import *dir() 函数 内置的函数 dir() 可以找到模块内定义的所有名称，以一个字符串列表的形式返回2.包包是一种管理 Python 模块命名空间的形式，采用”点模块名称” 比如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B 用户可以每次只导入一个包里面的特定模块，比如: 123import sound.effects.echo这将会导入子模块:sound.effects.echo 它必须使用全名去访问:sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 还有一种导入子模块的方法是: 123from sound.effects import echo这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:echo.echofilter(input, output, delay=0.7, atten=4) 还有一种变化就是直接导入一个函数或者变量: 123from sound.effects.echo import echofilter同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:echofilter(input, output, delay=0.7, atten=4) 基本数据类型变量不需要声明，直接赋值，且赋值后才能使用 1234counter = 1000name = &quot;wangjia&quot;a = b = c = 100 python基本类型 Number（数字） String（字符串） Tuple（元组） List（列表） Set（集合） Dictionary（字典） 注意：前三类是不可变类型 1.python数字类型 Numberint、bool、float、complex（复数） 可以删除对象引用 del var, (del var_a, var_b) 有很多数学函数可以直接调用，比如Java中Math函数中的很多计算函数，在python中直接用就可以，例如 ：abs(-1)，还有一些随机数函数，用的时候查就可以 2.字符串python中没有字符类型，单个字符当做字符串处理 字符串截取：变量[头下标:尾下标] 支持负数，负数代表从后往前截取 使用 “/“ 转义特殊字符，可以在字符串前加 “r” 表示原始字符，例如 r”abc/nvc” 注意字符串格式化： 一般用于日志输出，print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10)) 注意字符串中有四十多个功能内建函数，我们在操作判断关于字符串时查看以后函数是否支持 3.list 列表可以直接初始化: list = [‘12321’, 299, 12.80] 也支持截取，截取方法特性与字符串一样 list是可变的，可以更改元素，list[0] = ‘45654’, 或者批量修改：list[1:3] = [‘45654’, 300, 11.20] 删除元素：list[0] = [], list[0:2] = [] 合并列表，直接 + ，例如： list1 + list2。 list * 2 表示列表元素复制两倍 列表函数： 123456781. 获取长度函数：len(list)2. max(list)：返回列表元素最大值3. min(list)：返回列表元素最小值4. ist(seq)：将元组转换为列表5. list.append(obj)：在列表末尾添加新的对象6. list.index(obj)：从列表中找出某个值第一个匹配项的索引位置7. list.insert(index, obj)：将对象插入列表8. list.remove(obj)：移除列表中某个值的第一个匹配项 del可以根据索引来删除列表元素，例如： del list[2:4] 可以使用append和pop方法将列表作为堆栈使用，等等 4.tuple元组与list类似，但是元素不可变，也支持截取输出 tuple不可变，但是可以包含可变的对象，或list 创建空元组：tup1 = (); 元组不可以修改，但是可组合： tup3 = tup1 + tup2 元组元素不能删除，可以删除整个元组： del tup1 元组运算符支持与list一致 内置函数有：len、max、min、tuple 5.set集合创建方式： set = {1, 2, 3, 4} 或者，set(1) 创建空set 必须使用 set = set() 可以使用 in 关键字判断元素在不在set中， 例如 bool = 2 in set set支持运算，- 表示差集， | 表示并集， &amp; 交集， ^ 不同时存在的元素 基本内置函数： 12341. 添加元素：set.add(元素)2. 删除元素：set.remove( x )3. 计算元素个数：len(s)4. 清空集合：s.clear() 6.Dictionary字典列表是有序的对象集合，字典是无序的对象集合,字典当中的元素是通过键来存取的，类似于map 使用： dict = {} dict[“jjw”] = “wangjia” 字典键不能重复，值无所谓 可以这样创建：d = {key1 : value1, key2 : value2 } 使用字典取值的时候： dict[key] 如果key不存在于字典中，就会抛出异常 字典修改与 Kotlin修改map值一样 删除元素： del dict[key] 字典的键必须是不可变的，不可以使用列表作为键 基本内置函数： 12345671. len(dict)：计算字典元素个数，即键的总数2. str(dict)：输出字典，以可打印的字符串表示，类似于toString()3. radiansdict.get(key, default=None)：返回指定键的值，如果值不在字典中返回default值4. key in dict：如果键在字典dict里返回true，否则返回false5. radiansdict.items()：以列表返回可遍历的(键, 值) 元组数组6. radiansdict.keys()：返回一个迭代器，可以使用 list() 来转换为列表7. radiansdict.values()：返回一个迭代器，可以使用 list() 来转换为列表 遍历字典技巧： 123knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;for k, v in knights.items(): print(k, v) 7.数据转换方法：数据类型(数据) 即可。 例如 ： float(“10.00”) Python运算符数值运算符数值运算可以直接运算，运算的结果是精确的 (+、-、、/、%、*、\\) 主要说明：其他运算符于Java一致， /是精确除法，与Java不一样 ** 是幂，返回x的y次幂 // 取整除,向下取接近除数的整数 类似于我们Java中的 “&quot; 注意以上运算符都支持赋值运算，例如： += 、 *=、 //= 类型判断内置的 type() 函数可以用来查询变量所指的对象类型， isinstance()会判断类型是否属于某种类型 位运算与Java一致 逻辑运算符例如：a = 10; b = 20; and： x and y: 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20 or x or y: 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10 not not x: 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 一般用来判断变量在不在集合中，或者指定字符串中包含不包含特定字符串 身份运算符is: 是判断两个标识符是不是引用自一个对象 is not: 是判断两个标识符是不是引用自不同对象 例如：a = 10; b = 20; a is b 返回结果 true is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等 错误和异常异常即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常，异常的类型有多种，与Java类似 异常处理，使用类似于try-catch语句捕获处理： 12345678for arg in sys.argv[1:]: try: f = open(arg, &apos;r&apos;) except IOError: print(&apos;cannot open&apos;, arg) # 处理异常 else: # else语句表示没有发生任何异常的时候执行的代码块 print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;) f.close() except就类似于catch，except可以处理多个异常： 12except (RuntimeError, TypeError, NameError): pass 抛出异常Python 使用 raise 语句抛出一个指定的异常，示例： 1raise NameError(&apos;HiThere&apos;) 定义清理行为try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为，就是finally代码块，具体执行与Java类似： 123456789def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/tags/Python/"},{"name":"Python基础","slug":"Python基础","permalink":"https://jjw-story.github.io/tags/Python基础/"}],"author":"JJW"},{"title":"vim","slug":"vim","date":"2019-07-20T04:21:42.000Z","updated":"2019-07-25T02:02:10.245Z","comments":true,"path":"2019/07/20/vim/","link":"","permalink":"https://jjw-story.github.io/2019/07/20/vim/","excerpt":"","text":"vi编辑器vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 vim vi的多模式 正常模式(Normal-mode) 启动vim后默认处于正常模式，其他模式都可以用ESC键直接转换到正常模式。在这个模式我们键盘所敲的任何按键都是对vim所下的命令，如何进行复制如何进行粘贴都是要在这个模式下进行的。 命令模式(Command-mode) 是指可以在界面最底部的一行输入控制操作命令，主要用来进行一些文字编辑的辅助功能，比如字串搜寻、替代、保存文件，以及退出vim等。在命令行模式下输入”:”，或者是使用”?”和”/”键，就可以进入命令模式了。命令模式下输入的命令都会在最底部的一行中显示，按Enter键vim便会执行命令。 插入模式(Insert-mode) 插入模式用来修改文件内容的，只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 可视模式(Visual-mode) 有一些情况我们要进行一个高级编辑，比如对一块文件进行插入操作，就需要进入此模式。相当于高亮选取文本后的普通模式。在命令模式按下v, V, +v，ctrl+v可以进入可视模式。 vim编辑器所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在，但是目前我们使用比较多的是 vim 编辑器。 vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说，vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 vim正常模式首先使用vim命令进入正常模式，使用方法如下： vim [文件] 文件可以不写，类似于我们Windows记事本一样，可以点击一个文本文档打开，或者直接打开记事本进行编写内容。 正常模式常用命令 在正常模式下可以使用 i、I、a、A、o、O 命令进入到插入模式 i 表示从光标当前位置进入插入模式 I 表示从光标当前所在行的行首进入插入模式 a 表示从光标当前位置的下一位进入插入模式 A 表示从光标当前所在行的行尾进图插入模式 o 表示从当前光标所在行的下一行并插入一行进入插入模式 O 表示从当前光标所在行的上一行并插入一行进入插入模式 v命令 正常模式下输入 v 命令可以进入可视模式 :命令 可以进入命令模式，也称为末行模式 esc命令 在其他模式下可以使用 esc 返回到正常模式 h、j、k、l h 光标向左移动 l 光标向右移动 j 光标向下移动 k 光标向上移动 y复制命令 yy:复制光标所在行到缓冲区 nyy:注意n表示行数，表示复制当前行向下n行的内容 y$:复制当前光标所在位置到行尾的内容 yw:与y$效果一致 ny$:注意n表示字数，表示复制当前光标所在位置后n个字符 d剪切命令 dd:剪切光标所在行到缓冲区 ndd:注意n表示行数，表示剪切当前行向下n行的内容 d$:剪切光标所在位置到行尾的内容 dw:与d$效果一致 p粘贴命令 将复制或剪切的内容粘贴到光标所在位置 u撤销命令 撤销命令，可以将失误的操作进行撤销，如果我们连续失误了很多个命令，就多次使用u命令，一条一条撤销 Ctrl + r 重做撤销命令 就是将使用u命令撤销的命令重做，类似于撤回撤销 x命令 删除光标所在的单个字符 r命令 替换光标所在单个字符，使用时先按r键，再输入新的字符 n + G命令 n表示行数，G是大写，既将光标移动到指定的行 如果不指定 n 则直接将光标跳转到文件的最后一行 ^命令 将光标移动到所在行的行尾 $命令 将光标移动到所在行的行首 vim命令模式下面介绍命令模式常用命令操作 :w [文件名] 如果是新建文件，则使用 :w 文件目录+文件名 来将编辑好的内容保存为指定的文件 如果是修改文件，则直接使用 :w 命令保存文件 :q 使用 :q 退出vim w和q命令可以组合起来使用，直接 :wq 来保存并退出vim 注意：:wq 也可以使用快捷键 shift + z z 来实现 :q! 不保存退出 注意：可以使用快捷键 shift + z + q 来实现 :! 有时候我们在打开vim的时候，需要临时执行一条命令，并查看命令执行的结果，就可以使用 ！ 命令 12345678910111213:!ifconfigroot@CHJ-20190520VPS:/# vim /tmp/test.txteth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.113 netmask 255.255.255.240 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... / + 字符 向下搜索字符，例如使用 /h 可以在文本中查到h出现的地方，并将光标移动到第一次出现的位置 在查找到的时候，我们还可以使用 “n” 键来将光标移动到下一个此字符出现的位置 还可以使用 “shift + n” 来向上查到此字符出现的位置 ? + 字符 向上搜索字符，例如使用 /h 可以在文本中查到h出现的地方，并将光标移动到第一次出现的位置 在查找到的时候，我们还可以使用 “n” 键来将光标移动到下一个此字符出现的位置 还可以使用 “shift + n” 来向上查到此字符出现的位置 :s/旧的字符/新的字符 此命令的作用是将文本中旧的字符替换成新的字符，模式只是将光标当前所在行的字符替换 我们还可以将文本中每一行第一次出现的指定字符替换，可以使用命令 “:%s/旧的字符/新的字符” 如果我们需要将文本跟中所有的指定的字符替换为新的字符，就需要使用命令 “:%s/旧的字符/新的字符/g” ，命令中的g表示global 1234567891011sdaaaaaaaaaaaaaaaaaaaaaasdfsdaaaaasddsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag:%s/a/0/gsd0000000000000000000000sdfsd00000sdds00000000000000000000000000000000000000000000g 有的时候我们需要替换指定的行的特定字符，则需要使用命令 “:3,5/s/旧的字符/新的字符/g”, 表示将第3-5行中的旧的字符替换 :set命令 :set nu: 表示设置显示文本的行号 :set nonu: 表示关闭显示文本的行号 :set hlsearch 在使用查找字符命令时，高亮显示查找到的所有字符 :set nohlsearch 关闭查找字符高亮显示 默认情况下，我们使用set命令设置只在当次vim命令中生效，当我们下次进入vim的时候，set命令设置的东西就又会恢复为默认，这样的话很多时候回造成不必要的麻烦，如果我们需要将set命令设置的内容保存，以便于每次打开都能用，例如 set nu 命令，我们希望每次打开vim编辑文本的时候都能显示行号，这样的话，就需要去修改vim的配置文件，配置文件目录为：/etc/vim/vimrc 我们直接使用 vim /etc/vim/vimrc 命令编辑此配置文件，然后使用 G 命令直接将光标跳转到最后一行，然后使用命令 o 向下插入一行空行，直接编辑我们要设置的内容即可 添加如下： 123456&quot; Source a global configuration file if availableif filereadable(&quot;/etc/vim/vimrc.local&quot;) source /etc/vim/vimrc.localendifset nu 编辑完成之后，使用 esc 退出编辑模式，使用 :wq 保存并退出，这样当我们每次打开文件的时候就都会显示行号 vim插入模式 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 vim可视模式可视模式主要是针对于我们对文件的大量操作使用此模式一次性执行完成，通常我们都是配合 “I”, “d” 命令来快捷操作 可以在正常模式下使用 v、V、Ctrl + v三种方式进入: 命令 进入字符可视模式，字符可视模式就是当我们移动光标的时候，它是以字符为单位进行选择的 V 进入行可视模式，当我们移动光标的时候是对行进行选中 Ctrl + v 进入块可视模式，移动光标时选中的是上下对齐的一个块，此命令是使用较多的命令 使用示例如下： 我们要在多个行中同时插入一下字符，就可以使用vim先打开文件，然后使用 “Ctrl + v” 选中要操作的多个行为块，然后输入 “I” 命令进入行首进行编辑，插入我们要插入的字符后，连续按两次 esc 按键，就会发现，之前选中的行都被添加进去了我们新添加的字符 1234567891011 18 tyutyutyutyutyustyukcdefsdf 19 sdfsdf 20 sdf 21 sdf# 操作完成后 18 wangjia3tyutyutyutyutyustyukcdefsdf 19 wangjia3sdfsdf 20 wangjia3sdf 21 wangjia3sdf 也可以使用 “d” 命令，将选中的块或字符直接删除，使用方法同上，在块选择后，直接输入 d 即可完成删除，此命令比较常用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"vim","slug":"vim","permalink":"https://jjw-story.github.io/tags/vim/"}],"author":"JJW"},{"title":"打包压缩与解压缩","slug":"打包压缩与解压缩","date":"2019-07-17T11:43:36.000Z","updated":"2019-07-18T12:48:43.436Z","comments":true,"path":"2019/07/17/打包压缩与解压缩/","link":"","permalink":"https://jjw-story.github.io/2019/07/17/打包压缩与解压缩/","excerpt":"","text":"打包压缩与解压缩打包与压缩windows常见压缩文件格式：.rar .zip .7z Linux常见压缩文件格式 ：.tar.gz; .tar.bz2; .tgz; tbz2 在linux系统中，文件的格式与后缀名没有关系，一般压缩工具压缩之后会在压缩文件后添加对应压缩工具的后缀名 在Windows中，打包与压缩是一个软件功能，但是在Linux中，它是由两个软件构成的 打包命令Linux早期的打包命令其实是备份命令，备份的介质是磁带，使用的命令是 tar 可以对打包后的磁带文件进行压缩存储，压缩的命令是 gzip 和 bzip2，所以我们可以看到，打包和压缩的命令是分开的 tar命令打包的使用方法：tar [选项] 打包后的文件名 要打包的文件 注意：tar命令 使用tar命令需要了解它的选项，来帮助我们完成打包过程，常用的选项如下： c 建立压缩档案，及打包必须的参数 f 打包成文件并指定文件名称，切记，这个参数是最后一个参数，后面只能接文件名 使用示例： 123root@CHJ-20190520VPS:/# tar cf /tmp/etc-backup.tar /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# 如上示例中，我们将 /etc 目录打包成文件，放置在 /tmp 目录下，并指定打包后的文件名称为 etc-backup.tar ，执行命令后提示会把根目录开头的斜杠 “/“ 去掉，方便我们在解包的时候可以解压到任何目录 压缩命令单纯的打包的打包后的文件一般都很大，因为他并没有做过压缩，一般我们都会在存储的时候进行压缩，如上述打包文件的大小： 12root@CHJ-20190520VPS:/# ls -lh /tmp/etc-backup.tar-rw-r--r-- 1 root root 2.7M Jul 17 20:11 /tmp/etc-backup.tar 通常使用的压缩命令有 gzip bzip2 使用方法如下： gzip [文件名] bzip2 [文件名] 1234root@CHJ-20190520VPS:/# gzip /tmp/etc-backup.tarroot@CHJ-20190520VPS:/# ls -lh /tmptotal 488K-rw-r--r-- 1 root root 459K Jul 17 20:40 etc-backup.tar.gz 在我们使用tar命令的时候，其实已经把这两个命令集成进去了，只需要使用的时候添加参数就可以完成压缩解压缩，下面介绍使用此两个压缩命令的tar选项： z 打包文件并使用gzip压缩文件 j 打包文件并使用bzip2压缩文件 一般在使用打包和压缩命令时，为了方便人看到压缩文件是使用哪种压缩方式压缩的文件，对压缩后的文件使用双扩展名，例如 “xxx.tar.xx”，具体使用如下： 12345678910tar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# tar czf /tmp/etc-backup.tar.gz /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# ls -lh /tmptotal 1.0Mdrwxr-xr-x 1 root root 4.0K Jul 13 18:34 a-rw-r--r-- 1 root root 437K Jul 17 20:35 etc-backup.tar.bz2-rw-r--r-- 1 root root 459K Jul 17 20:35 etc-backup.tar.gz-rw-r--r-- 1 root root 551 Jul 14 14:03 testtextroot@CHJ-20190520VPS:/# 虽然压缩后的文件都不大，但是能感觉到使用 bzip2 压缩用的时间明显能更长一点，但是 bzip2 压缩后的文件更小一些，因为 bzip2 压缩后的比例更高一些 两种压缩方式都可以，如果我们希望压缩后的比例更高一下，就使用bzip2进行压缩 解压缩命令解压缩我们使用的命令还是 tar 命令，但是需要更换选项 使用方法：tar [参数] 压缩文件 [-C] [解压后目录] 常用选项说明： x 与上述 c 命令对应，x 参数是解压缩参数 f 与上述一致 v 显示所有进程，及压缩或解压明细 C 注意：C是大写，此选项是可以指定解压后的目录地址 使用示例： 12345root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar xf /tmp/etc-backup.tar -C /rootroot@CHJ-20190520VPS:/# ls /rootetc 将/tmp/etc-backup.tar压缩文件解压到 /root 目录下 实际我们见到的很多的压缩文件是 .tbz2 .tgz 的文件，这两种其实是 .tar.bz2 .tar.gz 的缩写，为了方便网络上的传播，将双扩展名的文件进行的缩写 解压我们不需要因为压缩软件的不同而使用不同的选项，只使用标准的 tar 解压就可以，如下： 12345678root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar -xvf /tmp/etc-backup.tar.gz -C /rootetc/etc/.pwd.lock...... 解压文件明细root@CHJ-20190520VPS:/# ls /rootetc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"打包压缩与解压缩","slug":"打包压缩与解压缩","permalink":"https://jjw-story.github.io/tags/打包压缩与解压缩/"}],"author":"JJW"},{"title":"文本查看命令","slug":"文本查看命令","date":"2019-07-15T05:55:16.000Z","updated":"2019-07-14T06:58:51.714Z","comments":true,"path":"2019/07/15/文本查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/15/文本查看命令/","excerpt":"","text":"文本查看命令cat命令显示文本文件内容，适用于查看整体内容，文件内容不多的，将所有的文本内容都显示到终端 使用方法：cat [参数] 文件 参数说明-n 显示的文本的行编号 -e 显示行结束符号$ 示例： 123456root@CHJ-20190520VPS:/tmp# cat -n -E testtext 1 sdf$ 2 $ 3 sd$ 4 f$ 5 ds$ head命令查看文件的开头的内容，默认显示文件开头的前十行 使用方法：head [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的前n行内容 1234root@CHJ-20190520VPS:/tmp# head -3 testtextsdfsd tail命令查看文件的末尾的内容，默认显示文件末的后十行 使用方法：tail [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的后n行内容 -f 循环读取文本信息，此命令一般用于文件内容在不断变化的文本查看，一般在查看服务器日志内容时使用 当我们看到文件在一直滚动循环查看，想要停止的时候，使用 ctrl + c命令，退出循环查看，即可停止来具体查看 wc命令wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 参数说明-l 统计文本文件的内容行数，一般我们在使用文本查看命令时，不清粗应该使用哪种命令来查看，可以使用此命令来查看文本的行数，然后选择要使用的文本查看命令 12root@CHJ-20190520VPS:/tmp# wc -l testtext206 testtext -c 统计字节数 -m 统计字符数。这个标志不能与 -c 标志一起使用 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 12root@CHJ-20190520VPS:/tmp# wc -L testtext7 testtext more命令分页显示文件内容，还支持直接跳转行等功能，最大的特点是查看每一页文本内容下方都会显示当前当前查看的文本内容所在位置百分比 使用方法：more 文件名 具体操作 Space：显示文本下一屏内容 Enter：只显示文本下一行内容 b：显示文本上一屏内容 q：退出 less命令分页显示文件内容，操作比more更为详细 使用方法：less [参数] 文件名 参数说明-m 显示类似more命令的百分比 -N 注意这里是大写N，显示每行的行号 具体操作 Space：显示文本下一屏内容 b：显示文本上一屏内容 Enter：前进一行 v：后退一行 d：前进半页 u：后退半页 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 q键：退出","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文本查看命令","slug":"文本查看命令","permalink":"https://jjw-story.github.io/tags/文本查看命令/"}],"author":"JJW"},{"title":"文件管理命令","slug":"文件管理命令","date":"2019-07-11T12:32:46.000Z","updated":"2019-07-14T05:53:08.747Z","comments":true,"path":"2019/07/11/文件管理命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/11/文件管理命令/","excerpt":"","text":"文件管理命令mkdir命令创建目录 使用方法：mkdir [参数] [目录…] 省略号代表可以建立多个目录 例如：建立一个 demo 目录 在根目录下建立：mkdir /demo 在当前目录下建立：mkdir ./demo “./“可以省略 建立多个目录：mkdir demo1 demo2 demo3 如果目录已存在，建立会失败 12root@CHJ-20190520VPS:/# mkdir homemkdir: cannot create directory ‘home’: File exists 参数的使用-p 一次创建多级目录，既父目录不存在先创建父目录 123456789101112root@CHJ-20190520VPS:/# mkdir -p a/b/c/droot@CHJ-20190520VPS:/# ls -R /a/a:b/a/b:c/a/b/c:d/a/b/c/d: 相比Windows，我们发现命令行的好处就在于可以一次创建多级目录 -v 显示目录创建的过程 123root@CHJ-20190520VPS:/# mkdir -p -v /e/fmkdir: created directory &apos;/e&apos;mkdir: created directory &apos;/e/f&apos; rmdir命令删除目录 使用方法：rmdir [目录…] 注意：rmdir 只能删除空的目录，删除非空目录会失败，必须逐级删除目录中的文件 12root@CHJ-20190520VPS:/# rmdir armdir: failed to remove &apos;a&apos;: Directory not empty rm命令删除文件或目录 使用方法：rm [参数] [目录…] 参数的使用-i 交互模式，在删除前询问用户是否操作 -r 如果删除的是目录，则需要使用此参数，作用是即使目录是非空的，也能逐级删除，但是每一级都要手动确认 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 特别需要注意这条命令，注意他的目录是可以写多个的，如果我们的命令写成 “rm -r -f / a “，既 不小心在 “/“ 与 “a” 之间多了一个空格，那么系统下所有的文件都会被删除，而且不会有任何提示。 所以我们在使用此项命令时一定要留意检查，避免操作失误 -r -f 可以合并使用： 12345root@CHJ-20190520VPS:/# mkdir -p a/b/c/d/f/eroot@CHJ-20190520VPS:/# rm -rf aroot@CHJ-20190520VPS:/# lsbin boot dev e etc home init lib lib64 media mnt opt proc root run sbin snap srv sys tmp usr varroot@CHJ-20190520VPS:/# cp命令文件复制命令，copy简写 使用方法： cp [参数] [文件…] 目录 cp [参数] [文件] 文件…目录 参数的使用-r 当我们直接使用cp命令复制目录的时候，是会失败的，因为cp命令本身是只复制文件，递归复制，用于目录的复制操作 12345root@CHJ-20190520VPS:/# cp a /tmpcp: -r not specified; omitting directory &apos;a&apos;root@CHJ-20190520VPS:/# cp -r a /tmproot@CHJ-20190520VPS:/# ls /tmpa -v 复制时显示复制信息，类似进度条，直接复制文件的时候不会有任何提示 12root@CHJ-20190520VPS:/# cp -v /filea /tmp&apos;/filea&apos; -&gt; &apos;/tmp/filea&apos; -p 与文件的属性一起复制，而非使用默认属性，例如文件创建更新时间 -a 与文件的属性一起复制，包括文件的属主，权限等 123456root@CHJ-20190520VPS:/# cp -v -a filea /tmp&apos;filea&apos; -&gt; &apos;/tmp/filea&apos;root@CHJ-20190520VPS:/# ls -l /tmp/filea-rw-r--r-- 1 root root 0 Jul 13 18:47 /tmp/filearoot@CHJ-20190520VPS:/# ls -l filea-rw-r--r-- 1 root root 0 Jul 13 18:47 filea -i 若目标文件已存在，在覆盖时会先询问是否真的操作 123root@CHJ-20190520VPS:/# cp -v -a -i filea /tmpcp: overwrite &apos;/tmp/filea&apos;? yes&apos;filea&apos; -&gt; &apos;/tmp/filea&apos; 注意词命令的第二种语法 表示将文件复制并重命令为自定义名称 12345root@CHJ-20190520VPS:/# cp -v -a -i -r filea /tmp/fileb&apos;filea&apos; -&gt; &apos;/tmp/fileb&apos;root@CHJ-20190520VPS:/# ls /tmpa filea filebroot@CHJ-20190520VPS:/# mv命令mv命令有两个功能，一个是文件及文件夹的移动功能，另一个是重命名功能 使用方法： mv [参数] 源文件 目录…文件名 重命名演示： 1234root@CHJ-20190520VPS:/# mv filea filebroot@CHJ-20190520VPS:/# lsa boot e fileb init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 注意：重命名的本质其实就是将文件移动 移动演示： 123root@CHJ-20190520VPS:/# mv fileb /tmproot@CHJ-20190520VPS:/# ls /tmpa filea fileb 还可以移动并重命名，使用命令： mv filea /tmp/filec 通配符的使用* *号表示匹配当前目录下所有目录及文件 使用示例，例如我们在 /tmp 目录下创建三个文件 filea、filebb、fileccc，然后使用通配符将此三个文件复制到其他目录下 123456root@CHJ-20190520VPS:/tmp# lsa dira dirb dirc filea fileb filecroot@CHJ-20190520VPS:/# cp /tmp/file* /root@CHJ-20190520VPS:/# lsa boot e filea fileccc init lib64 mnt proc run snap sys usrbin dev etc filebb home lib media opt root sbin srv tmp var ? ? 号与 * 作用相同，但是它只匹配一个字符，* 匹配多个字符 1234567891011root@CHJ-20190520VPS:/# lsa boot e home lib media opt root sbin srv tmp varbin dev etc init lib64 mnt proc run snap sys usrroot@CHJ-20190520VPS:/# ls /tmp/file*/tmp/filea /tmp/filebb /tmp/filecccroot@CHJ-20190520VPS:/# cp -v /tmp/file? /&apos;/tmp/filea&apos; -&gt; &apos;/filea&apos;root@CHJ-20190520VPS:/# lsa boot e filea init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 通过示例我们发现这里只复制过来 filea 目录，所以 ? 表示只匹配一个字符 注意上面我们使用ls命令也是用了通配符，表示通配符可以在很多命令中使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件管理命令","slug":"文件管理命令","permalink":"https://jjw-story.github.io/tags/文件管理命令/"}],"author":"JJW"},{"title":"文件查看命令","slug":"文件查看命令","date":"2019-07-08T04:55:40.000Z","updated":"2019-07-27T06:23:23.261Z","comments":true,"path":"2019/07/08/文件查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/08/文件查看命令/","excerpt":"","text":"文件查看命令文件管理命令是Linux管理的核心，因为Linux中有一个非常重要的概念-一切皆文件。在Windows系统中存在注册表、设备管理器了等等各种各样的组建来管理Windows，但是在Linux中，我们系统的管理控制等通通都是文件，所以文件管理命令是Linux管理中非常重要的内容。 pwd命令显示出完整的当前活动目录名称 注意：目录结构中 “/“ 目录和 “/root” 目录是两个不同的目录，”/“目录是我们的根目录，”/root”是root用户的家目录 ls命令列出目录的内容 使用方法：ls [选项] [文件名称…] 如果不写文件名称，默认代表当前目录 省略号表示支持多个文件或者目录名称，多个文件或目录中间用空格隔开（可以用多个空格） 查询内容有颜色不同，代表着不同的权限。不同的客户端颜色展示可能不同 ls基本选项说明-l使用详细格式列表，此命令可以直接缩写为 ll 命令执行如下及结果说明： 123456789root@CHJ-20190520VPS:/usr/lib# ls -ltotal 920drwxr-xr-x 1 root root 4096 May 21 22:39 kerneldrwxr-xr-x 1 root root 4096 May 21 22:39 klibcdrwxr-xr-x 1 root root 4096 May 21 22:40 language-selectorlrwxrwxrwx 1 root root 21 Feb 12 16:55 libDeployPkg.so.0 -&gt; libDeployPkg.so.0.0.0-rw-r--r-- 1 root root 31280 Feb 12 16:55 libDeployPkg.so.0.0.0lrwxrwxrwx 1 root root 20 Feb 12 16:55 libguestlib.so.0 -&gt; libguestlib.so.0.0.0-rw-r--r-- 1 root root 22656 Feb 12 16:55 libguestlib.so.0.0.0 一共查询出七列内容，分别表示： 文件属性(占10个字符空间)、拥有的文件数量、文件的创建者、所属的group、文件大小、建档日期、文件名 重点说明文件属性代表的内容： Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x） 但是这里有十个格子可以添（具体程序实现时，实际上是十个bit位） 第一个小格是特殊表示格，表示目录或连结文件等等，d表示目录，例如drwx——;l表示连结文件，如lrwxrwxrwx;如果是以一横“-”表示，则表示这是文件 其余剩下的格子就以每3格为一个单位，因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。 另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 -a显示全部文件包括隐藏的文件 Linux隐藏文件的目的是为了在用户日常操作中不会误操作或修改掉一些不可修改的文件内容 Linux创建隐藏文件的方式很简单，只需要在文件名前面加一个 “.” 即可 -t按照文件创建或最后修改的时间排序，默认是根据文件的名称来逆向排序 -r逆向排序显示文件 一般是配合 -l 来使用，例如： ls -l -r 如果我们需要按照文件的创建/修改时间来进行逆向排序则可以使用命令 “-t”，例如： ls -l -r -t 可以组合命令，多个参数不需要每个都用空格隔开，例如上述命令，可以写为： ls -lrt -R递归显示文件，就是罗列出当前文件中所有的文件及文件夹，还有子文件夹中的文件夹及文件，都罗列出来 -h将文件大小数据显示转化为可以阅读清楚的大小表示单位 –full-time列出文件完整的日期时间 –color={auto,never,always}用颜色来表示不同的文件类型，大括号内是参数选项 never：从不使用颜色表示不同类型 always：总是使用颜色表示不同类型 auto：根据终端属性自动确定是否使用颜色表示不同类型 cd命令cd命令用于切换当前工作目录至 dirName(目录参数) 使用方法： cd /path/to…绝对路径 cd /path/to…相对路径 注意一些特殊参数： 路径缺省，表示切换到当前用户的目录 ~ 也是切换到当前用户的目录 / 切换到根目录 ../ 切换到上一层目录，注意 “/“ 可以省略也可以 “cd ../..” 切换到上两级目录 - 切换到上一次访问的目录 12345wangjia3@CHJ-20190520VPS:/home$ pwd/homewangjia3@CHJ-20190520VPS:/home$ cd -/usr/local/libwangjia3@CHJ-20190520VPS:/usr/local/lib$ 当我们要切换的目录离根目录比较近，那就使用绝对路径 当我们要切换的目录离当前目录比较近，那就使用相对路径","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件查看命令","slug":"文件查看命令","permalink":"https://jjw-story.github.io/tags/文件查看命令/"}],"author":"JJW"},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2019-07-07T10:00:00.000Z","updated":"2019-07-08T10:43:36.792Z","comments":true,"path":"2019/07/07/IDEA快捷键/","link":"","permalink":"https://jjw-story.github.io/2019/07/07/IDEA快捷键/","excerpt":"","text":"IDEA快捷键 向上箭头 ctrl+i 向上一行选中 ctrl+shfit+i 当前行内容向上移动一行 ctrl+alt+i 当前行内容向上插入复制一行 ctrl+shift+alt+i 向下箭头 ctrl+k 向下选中一行 ctrl+shift+k 当前行内容向下移动一行 ctrl+alt+k 当前行内容向下插入复制一行 ctrl+shift+alt+k END ctrl+o 选中到END ctrl+shift+o HOME ctrl+u 选中到HOME ctrl+shift+u 向左移动一个单词 ctrl+j 向左移动一个字母 ctrl+alt+j 向左选中一个单词 ctrl+shift+j 向左选中一个字母 ctrl+shift+alt+j 向右移动一个单词 ctrl+l 向右移动一个字母 ctrl+alt+l 向右选中一个单词 ctrl+shift+l 向右选中一个字母 ctrl+shift+alt+l 打开行数跳转框 ctrl+g 切换到上一个编辑窗口 ctrl+, 切换到下一个编辑窗口 ctrl+. 关闭当前编辑窗口 ctrl+w 打开查找框 ctrl+f3 向下查找 f3 向上查找 shift+f3 显示意图动作 ctrl+空格，alt+enter project框移动 ctrl+i，ctrl+k 打开关闭：enter 删除一行 ctrl+alt+d 打开各种功能框 alt+功能框框对应数字 打开接口实现类，进入方法内部，获取方法在哪里被调用（类似eclipse的ctrl+alt+h） ctrl+b RUN shift+f9 DEBUG shift+f10 括号跳转（头-尾） ctrl+m+b","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/tags/IDEA/"}],"author":"JJW"},{"title":"帮助命令","slug":"帮助命令","date":"2019-07-06T12:58:05.000Z","updated":"2019-07-27T05:13:22.166Z","comments":true,"path":"2019/07/06/帮助命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/帮助命令/","excerpt":"","text":"man命令man命令 man是manual的缩写（有问题找男人帮忙） 使用方法：man [章数] [命令] 可以查询到要查询的命令具体作用、参数选项、描述等。查看完毕后按 q 退出 man命令本身也是一个命令，所以可以通过 [man man] 命令查看此命令本身的一些帮助文档 man命令帮助内容man命令帮助内容一共可以有九章的帮助内容，分别如下： Commands 用户可从 shell 运行的命令,查询第一章的内容的时候 1 可以省略 System calls 必须由内核完成的功能，系统调用 Library calls 大多数 libs 函数，如 sort(3) 此命令与第三章命令一般是用在我们在编程过程中获取函数的帮助文档使用的 Special files /dev 目录中的文件，第四章和第五章主要是文件的帮助 File formats and conventions /etc/pass 等人类可读的配置文件等格式及说明 Game Macro packages and conveentions 文件系统标准描述，网络协议，ASCII和其他字符集等 System Management commands 类似 mount(8) 等命令，大部分只能由 root 执行 Kernel routes 废弃的章节，原本是想把一些关于核心的文件放在这里 man一共有九个章节的帮助，分为这么多章主要是因为命令和系统调用还有文件有的时候会出现重名的情况，一旦重名，我们只单用一个man不加章节很难区分 例如 passwd 命令，这个命令是进行用户密码设置的命令，但是在我们的 /etc 目录下，还有一个 passwd 的一个配置文件，如果我们只使用 man passwd 的命令，很难区分出到底是对这个命令的帮助文档，还是对这个配置文件的帮助文档，这时，我们就可以通过章节这个参数来进行区分 有的时候我们并不知道要查看的帮助到底是命令还是配置文件等，可以使用 man a [参数] 来详细查看所有的帮助文档，在查看完一条之后，按 q 退出，即会提示有其他条的帮助文档，我们可以选择查看 man命令说明页含义 标头 含义 Name 命令的名称和用途 Synopsis 命令语法 Description 完整描述 Environment 命令使用的环境变量 Author 开发该程序者 Files 对该命令重要的文件列表 See also 相关信息 Diagnostics 可能的错误和警告 Bugs （可能没有） help命令help命令也是帮助命令，它使用分为内部命令使用帮助、外部命令使用帮助 内部命令和外部命令shell（命令解释器）自带的命令成为内部命令，其他的是外部命令 内部命令内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。 外部命令外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。可通过 “echo $PATH” 命令查看外部命令的存储路径，比如：ls、vi等。 使用type命令区分内外部命令使用方法：type [命令] 1234root@CHJ-20190520VPS:~# type cdcd is a shell builtinroot@CHJ-20190520VPS:~# type mkdirmkdir is /bin/mkdir 内部命令和外部命令最大的区别之处就是性能。内部命令由于构建在shell中而不必创建多余的进程，要比外部命令执行快得多。因此和执行更大的脚本道理一样，执行包含很多外部命令的脚本会损害脚本的性能。 help命令用法 内部命令 help [命令] 外部命令 [命令] --help 帮助命令总结Linux的基本操作方式是命令行，通过命令行的话就需要熟记很多的操作命令，但是海量的命令不适合死记硬背。 当我们使用到陌生的命令的时候，就可以使用 man help 等帮助命令查询它的帮助文档，来帮助我们了解这些命令。 注意：很多内部命令 man 是没有帮助文档的，所以我们使用更多的应该是 help 命令。 which命令查看可执行文件的位置，从全局环境变量PATH里面查找对应的路径，默认是找 bash内所规范的目录，一般用来确认系统中是否安装了指定软件 在PATH变量指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果 使用方法：which [参数] 命令 -a 打印出PATH中的所有匹配项，而不是仅仅第一个 –skip-dot 跳过PATH中以点开头的目录 –skip-tilde 跳过PATH中以波浪号开头的目录 使用示例： 1234root@CHJ-20190520VPS:~# which shutdown/sbin/shutdownroot@CHJ-20190520VPS:~# which cdroot@CHJ-20190520VPS:~# 注意：我们发现查找 cd 命令竟然没有找到，这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"帮助命令","slug":"帮助命令","permalink":"https://jjw-story.github.io/tags/帮助命令/"}],"author":"JJW"},{"title":"初识Linux","slug":"什么是Linux","date":"2019-07-06T01:49:19.000Z","updated":"2019-07-07T04:57:08.258Z","comments":true,"path":"2019/07/06/什么是Linux/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/什么是Linux/","excerpt":"","text":"什么是LinuxLinux有两种含义 一种是Linus编写的操作系统的内核 另一种是广义的操作系统 一般我们所说的Linux就是说广义的操作系统 服务端操作系统一般都是使用命令行的方式进行操作,主要因为服务端操作系统与客户端操作系统所做的事情不一样,服务端主要追求稳定 Linux版本内核版本 内核版本分为三个部分,一般使用的是稳定版 稳定版又分为三个版本号，分别是 主版本号 次版本号 末版本号 次版本号为奇数为开发版，偶数为稳定版 发行版本 Red Hat EnterPrise 特点：软件经过专业人员的测试，非常稳定，有大公司支持，但是在技术支持和更新最新的安全漏洞补丁的时候是需要付费的 Fedora 特点：也是Red Hat公司发行的，不同之处是发行方式是组建一个社区，来免费提供操作系统，软件要比上述新，但是没有经过专业的测试，稳定性要差 CentOS 特点：基于Red Hat EnterPrise源代码进行编译的，可以免费试用 Ubuntu 特点：定制了非常华丽的界面，可以直接安装在PC机上进行操作 Debian 特点：与Ubantu一样 终端的使用 图形终端 命令行终端 远程终端（SSH VNC） 通过互联网远程连接终端，实际生产使用较多 Linux常见目录介绍 / 根目录 /root root用户的家目录 /home/username 普通用户的家目录 /etc 配置文件目录 /bin 命令目录 /sbin 管理命令目录 /usr/bin /usr/sbin 系统预装的其他命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"overview","slug":"overview","permalink":"https://jjw-story.github.io/tags/overview/"}],"author":"JJW"}]}