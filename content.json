{"meta":{"title":"JJW-STORY","subtitle":null,"description":null,"author":"JJW","url":"https://jjw-story.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-06T09:23:47.544Z","updated":"2019-07-06T09:23:47.544Z","comments":true,"path":"about/index.html","permalink":"https://jjw-story.github.io/about/index.html","excerpt":"","text":"关于我北京车和家信息技术有限公司~~开发工程师 关于工作城市：北京 关于学习每天都走在学习的大路上 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好杂乱无章 联系我 Home: JJW-STORE.GITHUB.IO Blog: JJW-STORE.GITHUB.IO Email: CHINAGOLDWJ@163.COM GitHub: JJW-STORE WeiBo: JJWStrive"}],"posts":[{"title":"打包压缩与解压缩","slug":"打包压缩与解压缩","date":"2019-07-17T11:43:36.000Z","updated":"2019-07-18T12:48:43.436Z","comments":true,"path":"2019/07/17/打包压缩与解压缩/","link":"","permalink":"https://jjw-story.github.io/2019/07/17/打包压缩与解压缩/","excerpt":"","text":"打包压缩与解压缩打包与压缩windows常见压缩文件格式：.rar .zip .7z Linux常见压缩文件格式 ：.tar.gz; .tar.bz2; .tgz; tbz2 在linux系统中，文件的格式与后缀名没有关系，一般压缩工具压缩之后会在压缩文件后添加对应压缩工具的后缀名 在Windows中，打包与压缩是一个软件功能，但是在Linux中，它是由两个软件构成的 打包命令Linux早期的打包命令其实是备份命令，备份的介质是磁带，使用的命令是 tar 可以对打包后的磁带文件进行压缩存储，压缩的命令是 gzip 和 bzip2，所以我们可以看到，打包和压缩的命令是分开的 tar命令打包的使用方法：tar [选项] 打包后的文件名 要打包的文件 注意：tar命令 使用tar命令需要了解它的选项，来帮助我们完成打包过程，常用的选项如下： c 建立压缩档案，及打包必须的参数 f 打包成文件并指定文件名称，切记，这个参数是最后一个参数，后面只能接文件名 使用示例： 123root@CHJ-20190520VPS:/# tar cf /tmp/etc-backup.tar /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# 如上示例中，我们将 /etc 目录打包成文件，放置在 /tmp 目录下，并指定打包后的文件名称为 etc-backup.tar ，执行命令后提示会把根目录开头的斜杠 “/“ 去掉，方便我们在解包的时候可以解压到任何目录 压缩命令单纯的打包的打包后的文件一般都很大，因为他并没有做过压缩，一般我们都会在存储的时候进行压缩，如上述打包文件的大小： 12root@CHJ-20190520VPS:/# ls -lh /tmp/etc-backup.tar-rw-r--r-- 1 root root 2.7M Jul 17 20:11 /tmp/etc-backup.tar 通常使用的压缩命令有 gzip bzip2 使用方法如下： gzip [文件名] bzip2 [文件名] 1234root@CHJ-20190520VPS:/# gzip /tmp/etc-backup.tarroot@CHJ-20190520VPS:/# ls -lh /tmptotal 488K-rw-r--r-- 1 root root 459K Jul 17 20:40 etc-backup.tar.gz 在我们使用tar命令的时候，其实已经把这两个命令集成进去了，只需要使用的时候添加参数就可以完成压缩解压缩，下面介绍使用此两个压缩命令的tar选项： z 打包文件并使用gzip压缩文件 j 打包文件并使用bzip2压缩文件 一般在使用打包和压缩命令时，为了方便人看到压缩文件是使用哪种压缩方式压缩的文件，对压缩后的文件使用双扩展名，例如 “xxx.tar.xx”，具体使用如下： 12345678910tar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# tar czf /tmp/etc-backup.tar.gz /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# ls -lh /tmptotal 1.0Mdrwxr-xr-x 1 root root 4.0K Jul 13 18:34 a-rw-r--r-- 1 root root 437K Jul 17 20:35 etc-backup.tar.bz2-rw-r--r-- 1 root root 459K Jul 17 20:35 etc-backup.tar.gz-rw-r--r-- 1 root root 551 Jul 14 14:03 testtextroot@CHJ-20190520VPS:/# 虽然压缩后的文件都不大，但是能感觉到使用 bzip2 压缩用的时间明显能更长一点，但是 bzip2 压缩后的文件更小一些，因为 bzip2 压缩后的比例更高一些 两种压缩方式都可以，如果我们希望压缩后的比例更高一下，就使用bzip2进行压缩 解压缩命令解压缩我们使用的命令还是 tar 命令，但是需要更换选项 使用方法：tar [参数] 压缩文件 [-C] [解压后目录] 常用选项说明： x 与上述 c 命令对应，x 参数是解压缩参数 f 与上述一致 v 显示所有进程，及压缩或解压明细 C 注意：C是大写，此选项是可以指定解压后的目录地址 使用示例： 12345root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar xf /tmp/etc-backup.tar -C /rootroot@CHJ-20190520VPS:/# ls /rootetc 将/tmp/etc-backup.tar压缩文件解压到 /root 目录下 实际我们见到的很多的压缩文件是 .tbz2 .tgz 的文件，这两种其实是 .tar.bz2 .tar.gz 的缩写，为了方便网络上的传播，将双扩展名的文件进行的缩写 解压我们不需要因为压缩软件的不同而使用不同的选项，只使用标准的 tar 解压就可以，如下： 12345678root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar -xvf /tmp/etc-backup.tar.gz -C /rootetc/etc/.pwd.lock...... 解压文件明细root@CHJ-20190520VPS:/# ls /rootetc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"打包压缩与解压缩","slug":"打包压缩与解压缩","permalink":"https://jjw-story.github.io/tags/打包压缩与解压缩/"}],"author":"JJW"},{"title":"文本查看命令","slug":"文本查看命令","date":"2019-07-15T05:55:16.000Z","updated":"2019-07-14T06:58:51.714Z","comments":true,"path":"2019/07/15/文本查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/15/文本查看命令/","excerpt":"","text":"文本查看命令cat命令显示文本文件内容，适用于查看整体内容，文件内容不多的，将所有的文本内容都显示到终端 使用方法：cat [参数] 文件 参数说明-n 显示的文本的行编号 -e 显示行结束符号$ 示例： 123456root@CHJ-20190520VPS:/tmp# cat -n -E testtext 1 sdf$ 2 $ 3 sd$ 4 f$ 5 ds$ head命令查看文件的开头的内容，默认显示文件开头的前十行 使用方法：head [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的前n行内容 1234root@CHJ-20190520VPS:/tmp# head -3 testtextsdfsd tail命令查看文件的末尾的内容，默认显示文件末的后十行 使用方法：tail [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的后n行内容 -f 循环读取文本信息，此命令一般用于文件内容在不断变化的文本查看，一般在查看服务器日志内容时使用 当我们看到文件在一直滚动循环查看，想要停止的时候，使用 ctrl + c命令，退出循环查看，即可停止来具体查看 wc命令wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 参数说明-l 统计文本文件的内容行数，一般我们在使用文本查看命令时，不清粗应该使用哪种命令来查看，可以使用此命令来查看文本的行数，然后选择要使用的文本查看命令 12root@CHJ-20190520VPS:/tmp# wc -l testtext206 testtext -c 统计字节数 -m 统计字符数。这个标志不能与 -c 标志一起使用 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 12root@CHJ-20190520VPS:/tmp# wc -L testtext7 testtext more命令分页显示文件内容，还支持直接跳转行等功能，最大的特点是查看每一页文本内容下方都会显示当前当前查看的文本内容所在位置百分比 使用方法：more 文件名 具体操作 Space：显示文本下一屏内容 Enter：只显示文本下一行内容 b：显示文本上一屏内容 q：退出 less命令分页显示文件内容，操作比more更为详细 使用方法：less [参数] 文件名 参数说明-m 显示类似more命令的百分比 -N 注意这里是大写N，显示每行的行号 具体操作 Space：显示文本下一屏内容 b：显示文本上一屏内容 Enter：前进一行 v：后退一行 d：前进半页 u：后退半页 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 q键：退出","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文本查看命令","slug":"文本查看命令","permalink":"https://jjw-story.github.io/tags/文本查看命令/"}],"author":"JJW"},{"title":"文件管理命令","slug":"文件管理命令","date":"2019-07-11T12:32:46.000Z","updated":"2019-07-14T05:53:08.747Z","comments":true,"path":"2019/07/11/文件管理命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/11/文件管理命令/","excerpt":"","text":"文件管理命令mkdir命令创建目录 使用方法：mkdir [参数] [目录…] 省略号代表可以建立多个目录 例如：建立一个 demo 目录 在根目录下建立：mkdir /demo 在当前目录下建立：mkdir ./demo “./“可以省略 建立多个目录：mkdir demo1 demo2 demo3 如果目录已存在，建立会失败 12root@CHJ-20190520VPS:/# mkdir homemkdir: cannot create directory ‘home’: File exists 参数的使用-p 一次创建多级目录，既父目录不存在先创建父目录 123456789101112root@CHJ-20190520VPS:/# mkdir -p a/b/c/droot@CHJ-20190520VPS:/# ls -R /a/a:b/a/b:c/a/b/c:d/a/b/c/d: 相比Windows，我们发现命令行的好处就在于可以一次创建多级目录 -v 显示目录创建的过程 123root@CHJ-20190520VPS:/# mkdir -p -v /e/fmkdir: created directory &apos;/e&apos;mkdir: created directory &apos;/e/f&apos; rmdir命令删除目录 使用方法：rmdir [目录…] 注意：rmdir 只能删除空的目录，删除非空目录会失败，必须逐级删除目录中的文件 12root@CHJ-20190520VPS:/# rmdir armdir: failed to remove &apos;a&apos;: Directory not empty rm命令删除文件或目录 使用方法：rm [参数] [目录…] 参数的使用-i 交互模式，在删除前询问用户是否操作 -r 如果删除的是目录，则需要使用此参数，作用是即使目录是非空的，也能逐级删除，但是每一级都要手动确认 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 特别需要注意这条命令，注意他的目录是可以写多个的，如果我们的命令写成 “rm -r -f / a “，既 不小心在 “/“ 与 “a” 之间多了一个空格，那么系统下所有的文件都会被删除，而且不会有任何提示。 所以我们在使用此项命令时一定要留意检查，避免操作失误 -r -f 可以合并使用： 12345root@CHJ-20190520VPS:/# mkdir -p a/b/c/d/f/eroot@CHJ-20190520VPS:/# rm -rf aroot@CHJ-20190520VPS:/# lsbin boot dev e etc home init lib lib64 media mnt opt proc root run sbin snap srv sys tmp usr varroot@CHJ-20190520VPS:/# cp命令文件复制命令，copy简写 使用方法： cp [参数] [文件…] 目录 cp [参数] [文件] 文件…目录 参数的使用-r 当我们直接使用cp命令复制目录的时候，是会失败的，因为cp命令本身是只复制文件，递归复制，用于目录的复制操作 12345root@CHJ-20190520VPS:/# cp a /tmpcp: -r not specified; omitting directory &apos;a&apos;root@CHJ-20190520VPS:/# cp -r a /tmproot@CHJ-20190520VPS:/# ls /tmpa -v 复制时显示复制信息，类似进度条，直接复制文件的时候不会有任何提示 12root@CHJ-20190520VPS:/# cp -v /filea /tmp&apos;/filea&apos; -&gt; &apos;/tmp/filea&apos; -p 与文件的属性一起复制，而非使用默认属性，例如文件创建更新时间 -a 与文件的属性一起复制，包括文件的属主，权限等 123456root@CHJ-20190520VPS:/# cp -v -a filea /tmp&apos;filea&apos; -&gt; &apos;/tmp/filea&apos;root@CHJ-20190520VPS:/# ls -l /tmp/filea-rw-r--r-- 1 root root 0 Jul 13 18:47 /tmp/filearoot@CHJ-20190520VPS:/# ls -l filea-rw-r--r-- 1 root root 0 Jul 13 18:47 filea -i 若目标文件已存在，在覆盖时会先询问是否真的操作 123root@CHJ-20190520VPS:/# cp -v -a -i filea /tmpcp: overwrite &apos;/tmp/filea&apos;? yes&apos;filea&apos; -&gt; &apos;/tmp/filea&apos; 注意词命令的第二种语法 表示将文件复制并重命令为自定义名称 12345root@CHJ-20190520VPS:/# cp -v -a -i -r filea /tmp/fileb&apos;filea&apos; -&gt; &apos;/tmp/fileb&apos;root@CHJ-20190520VPS:/# ls /tmpa filea filebroot@CHJ-20190520VPS:/# mv命令mv命令有两个功能，一个是文件及文件夹的移动功能，另一个是重命名功能 使用方法： mv [参数] 源文件 目录…文件名 重命名演示： 1234root@CHJ-20190520VPS:/# mv filea filebroot@CHJ-20190520VPS:/# lsa boot e fileb init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 注意：重命名的本质其实就是将文件移动 移动演示： 123root@CHJ-20190520VPS:/# mv fileb /tmproot@CHJ-20190520VPS:/# ls /tmpa filea fileb 还可以移动并重命名，使用命令： mv filea /tmp/filec 通配符的使用* *号表示匹配当前目录下所有目录及文件 使用示例，例如我们在 /tmp 目录下创建三个文件 filea、filebb、fileccc，然后使用通配符将此三个文件复制到其他目录下 123456root@CHJ-20190520VPS:/tmp# lsa dira dirb dirc filea fileb filecroot@CHJ-20190520VPS:/# cp /tmp/file* /root@CHJ-20190520VPS:/# lsa boot e filea fileccc init lib64 mnt proc run snap sys usrbin dev etc filebb home lib media opt root sbin srv tmp var ? ? 号与 * 作用相同，但是它只匹配一个字符，* 匹配多个字符 1234567891011root@CHJ-20190520VPS:/# lsa boot e home lib media opt root sbin srv tmp varbin dev etc init lib64 mnt proc run snap sys usrroot@CHJ-20190520VPS:/# ls /tmp/file*/tmp/filea /tmp/filebb /tmp/filecccroot@CHJ-20190520VPS:/# cp -v /tmp/file? /&apos;/tmp/filea&apos; -&gt; &apos;/filea&apos;root@CHJ-20190520VPS:/# lsa boot e filea init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 通过示例我们发现这里只复制过来 filea 目录，所以 ? 表示只匹配一个字符 注意上面我们使用ls命令也是用了通配符，表示通配符可以在很多命令中使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件管理命令","slug":"文件管理命令","permalink":"https://jjw-story.github.io/tags/文件管理命令/"}],"author":"JJW"},{"title":"文件查看命令","slug":"文件查看命令","date":"2019-07-08T04:55:40.000Z","updated":"2019-07-10T12:33:49.245Z","comments":true,"path":"2019/07/08/文件查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/08/文件查看命令/","excerpt":"","text":"文件查看命令文件管理命令是Linux管理的核心，因为Linux中有一个非常重要的概念-一切皆文件。在Windows系统中存在注册表、设备管理器了等等各种各样的组建来管理Windows，但是在Linux中，我们系统的管理控制等通通都是文件，所以文件管理命令是Linux管理中非常重要的内容。 pwd命令显示出完整的当前活动目录名称 注意：目录结构中 “/“ 目录和 “/root” 目录是两个不同的目录，”/“目录是我们的根目录，”/root”是root用户的家目录 ls命令列出目录的内容 使用方法：ls [选项] [文件名称…] 如果不写文件名称，默认代表当前目录 省略号表示支持多个文件或者目录名称，多个文件或目录中间用空格隔开（可以用多个空格） 查询内容有颜色不同，代表着不同的权限。不同的客户端颜色展示可能不同 ls基本选项说明-l使用详细格式列表，此命令可以直接缩写为 ll 命令执行如下及结果说明： 123456789root@CHJ-20190520VPS:/usr/lib# ls -ltotal 920drwxr-xr-x 1 root root 4096 May 21 22:39 kerneldrwxr-xr-x 1 root root 4096 May 21 22:39 klibcdrwxr-xr-x 1 root root 4096 May 21 22:40 language-selectorlrwxrwxrwx 1 root root 21 Feb 12 16:55 libDeployPkg.so.0 -&gt; libDeployPkg.so.0.0.0-rw-r--r-- 1 root root 31280 Feb 12 16:55 libDeployPkg.so.0.0.0lrwxrwxrwx 1 root root 20 Feb 12 16:55 libguestlib.so.0 -&gt; libguestlib.so.0.0.0-rw-r--r-- 1 root root 22656 Feb 12 16:55 libguestlib.so.0.0.0 一共查询出七列内容，分别表示： 文件属性(占10个字符空间)、拥有的文件数量、文件的创建者、所属的group、文件大小、建档日期、文件名 重点说明文件属性代表的内容： Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x） 但是这里有十个格子可以添（具体程序实现时，实际上是十个bit位） 第一个小格是特殊表示格，表示目录或连结文件等等，d表示目录，例如drwx——;l表示连结文件，如lrwxrwxrwx;如果是以一横“-”表示，则表示这是文件 其余剩下的格子就以每3格为一个单位，因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。 另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 -a显示全部文件包括隐藏的文件 Linux隐藏文件的目的是为了在用户日常操作中不会误操作或修改掉一些不可修改的文件内容 Linux创建隐藏文件的方式很简单，只需要在文件名前面加一个 “.” 即可 -t按照文件创建或最后修改的时间排序，默认是根据文件的名称来逆向排序 -r逆向排序显示文件 一般是配合 -l 来使用，例如： ls -l -r 如果我们需要按照文件的创建/修改时间来进行逆向排序则可以使用命令 “-t”，例如： ls -l -r -t 可以组合命令，多个参数不需要每个都用空格隔开，例如上述命令，可以写为： ls -lrt -R递归显示文件，就是罗列出当前文件中所有的文件及文件夹，还有子文件夹中的文件夹及文件，都罗列出来 -h将文件大小数据显示转化为可以阅读清楚的大小表示单位 –full-time列出文件完整的日期时间 –color={auto,never,always}用颜色来表示不同的文件类型，大括号内是参数选项 never：从不使用颜色表示不同类型 always：总是使用颜色表示不同类型 auto：根据终端属性自动确定是否使用颜色表示不同类型 cd命令cd命令用于切换当前工作目录至 dirName(目录参数) 使用方法： cd /path/to…绝对路径 cd /path/to…相对路径 注意一些特殊参数： 路径缺省，表示切换到当前用户的目录 ~ 也是切换到当前用户的目录 / 切换到根目录 ../ 切换到上一层目录，注意 “/“ 可以省略也可以 “cd ../..” 切换到上两级目录 - 切换到上一次访问的目录 12345wangjia3@CHJ-20190520VPS:/home$ pwd/homewangjia3@CHJ-20190520VPS:/home$ cd -/usr/local/libwangjia3@CHJ-20190520VPS:/usr/local/lib$ 当我们要切换的目录离根目录比较近，那就使用绝对路径 当我们要切换的目录离当前目录比较近，那就使用相对路径","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件查看命令","slug":"文件查看命令","permalink":"https://jjw-story.github.io/tags/文件查看命令/"}],"author":"JJW"},{"title":"help命令","slug":"help命令","date":"2019-07-07T12:00:00.000Z","updated":"2019-07-08T11:18:47.368Z","comments":true,"path":"2019/07/07/help命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/07/help命令/","excerpt":"","text":"help命令help命令也是帮助命令，它使用分为内部命令使用帮助、外部命令使用帮助 内部命令和外部命令shell（命令解释器）自带的命令成为内部命令，其他的是外部命令 内部命令内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。 外部命令外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。可通过 “echo $PATH” 命令查看外部命令的存储路径，比如：ls、vi等。 使用type命令区分内外部命令使用方法：type [命令] 1234root@CHJ-20190520VPS:~# type cdcd is a shell builtinroot@CHJ-20190520VPS:~# type mkdirmkdir is /bin/mkdir 内部命令和外部命令最大的区别之处就是性能。内部命令由于构建在shell中而不必创建多余的进程，要比外部命令执行快得多。因此和执行更大的脚本道理一样，执行包含很多外部命令的脚本会损害脚本的性能。 help命令用法 内部命令 help [命令] 外部命令 [命令] --help 帮助命令总结Linux的基本操作方式是命令行，通过命令行的话就需要熟记很多的操作命令，但是海量的命令不适合死记硬背。 当我们使用到陌生的命令的时候，就可以使用 man help 等帮助命令查询它的帮助文档，来帮助我们了解这些命令。 注意：很多内部命令 man 是没有帮助文档的，所以我们使用更多的应该是 help 命令。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"帮助命令","slug":"帮助命令","permalink":"https://jjw-story.github.io/tags/帮助命令/"}],"author":"JJW"},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2019-07-07T10:00:00.000Z","updated":"2019-07-08T10:43:36.792Z","comments":true,"path":"2019/07/07/IDEA快捷键/","link":"","permalink":"https://jjw-story.github.io/2019/07/07/IDEA快捷键/","excerpt":"","text":"IDEA快捷键 向上箭头 ctrl+i 向上一行选中 ctrl+shfit+i 当前行内容向上移动一行 ctrl+alt+i 当前行内容向上插入复制一行 ctrl+shift+alt+i 向下箭头 ctrl+k 向下选中一行 ctrl+shift+k 当前行内容向下移动一行 ctrl+alt+k 当前行内容向下插入复制一行 ctrl+shift+alt+k END ctrl+o 选中到END ctrl+shift+o HOME ctrl+u 选中到HOME ctrl+shift+u 向左移动一个单词 ctrl+j 向左移动一个字母 ctrl+alt+j 向左选中一个单词 ctrl+shift+j 向左选中一个字母 ctrl+shift+alt+j 向右移动一个单词 ctrl+l 向右移动一个字母 ctrl+alt+l 向右选中一个单词 ctrl+shift+l 向右选中一个字母 ctrl+shift+alt+l 打开行数跳转框 ctrl+g 切换到上一个编辑窗口 ctrl+, 切换到下一个编辑窗口 ctrl+. 关闭当前编辑窗口 ctrl+w 打开查找框 ctrl+f3 向下查找 f3 向上查找 shift+f3 显示意图动作 ctrl+空格，alt+enter project框移动 ctrl+i，ctrl+k 打开关闭：enter 删除一行 ctrl+alt+d 打开各种功能框 alt+功能框框对应数字 打开接口实现类，进入方法内部，获取方法在哪里被调用（类似eclipse的ctrl+alt+h） ctrl+b RUN shift+f9 DEBUG shift+f10 括号跳转（头-尾） ctrl+m+b","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/tags/IDEA/"}],"author":"JJW"},{"title":"man命令","slug":"man命令","date":"2019-07-06T12:58:05.000Z","updated":"2019-07-07T06:39:40.056Z","comments":true,"path":"2019/07/06/man命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/man命令/","excerpt":"","text":"man命令man命令 man是manual的缩写（有问题找男人帮忙） 使用方法：man [章数] [命令] 可以查询到要查询的命令具体作用、参数选项、描述等。查看完毕后按 q 退出 man命令本身也是一个命令，所以可以通过 [man man] 命令查看此命令本身的一些帮助文档 man命令帮助内容man命令帮助内容一共可以有九章的帮助内容，分别如下： Commands 用户可从 shell 运行的命令,查询第一章的内容的时候 1 可以省略 System calls 必须由内核完成的功能，系统调用 Library calls 大多数 libs 函数，如 sort(3) 此命令与第三章命令一般是用在我们在编程过程中获取函数的帮助文档使用的 Special files /dev 目录中的文件，第四章和第五章主要是文件的帮助 File formats and conventions /etc/pass 等人类可读的配置文件等格式及说明 Game Macro packages and conveentions 文件系统标准描述，网络协议，ASCII和其他字符集等 System Management commands 类似 mount(8) 等命令，大部分只能由 root 执行 Kernel routes 废弃的章节，原本是想把一些关于核心的文件放在这里 man一共有九个章节的帮助，分为这么多章主要是因为命令和系统调用还有文件有的时候会出现重名的情况，一旦重名，我们只单用一个man不加章节很难区分 例如 passwd 命令，这个命令是进行用户密码设置的命令，但是在我们的 /etc 目录下，还有一个 passwd 的一个配置文件，如果我们只使用 man passwd 的命令，很难区分出到底是对这个命令的帮助文档，还是对这个配置文件的帮助文档，这时，我们就可以通过章节这个参数来进行区分 有的时候我们并不知道要查看的帮助到底是命令还是配置文件等，可以使用 man a [参数] 来详细查看所有的帮助文档，在查看完一条之后，按 q 退出，即会提示有其他条的帮助文档，我们可以选择查看 man命令说明页含义 标头 含义 Name 命令的名称和用途 Synopsis 命令语法 Description 完整描述 Environment 命令使用的环境变量 Author 开发该程序者 Files 对该命令重要的文件列表 See also 相关信息 Diagnostics 可能的错误和警告 Bugs （可能没有）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"帮助命令","slug":"帮助命令","permalink":"https://jjw-story.github.io/tags/帮助命令/"}],"author":"JJW"},{"title":"初识Linux","slug":"什么是Linux","date":"2019-07-06T01:49:19.000Z","updated":"2019-07-07T04:57:08.258Z","comments":true,"path":"2019/07/06/什么是Linux/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/什么是Linux/","excerpt":"","text":"什么是LinuxLinux有两种含义 一种是Linus编写的操作系统的内核 另一种是广义的操作系统 一般我们所说的Linux就是说广义的操作系统 服务端操作系统一般都是使用命令行的方式进行操作,主要因为服务端操作系统与客户端操作系统所做的事情不一样,服务端主要追求稳定 Linux版本内核版本 内核版本分为三个部分,一般使用的是稳定版 稳定版又分为三个版本号，分别是 主版本号 次版本号 末版本号 次版本号为奇数为开发版，偶数为稳定版 发行版本 Red Hat EnterPrise 特点：软件经过专业人员的测试，非常稳定，有大公司支持，但是在技术支持和更新最新的安全漏洞补丁的时候是需要付费的 Fedora 特点：也是Red Hat公司发行的，不同之处是发行方式是组建一个社区，来免费提供操作系统，软件要比上述新，但是没有经过专业的测试，稳定性要差 CentOS 特点：基于Red Hat EnterPrise源代码进行编译的，可以免费试用 Ubuntu 特点：定制了非常华丽的界面，可以直接安装在PC机上进行操作 Debian 特点：与Ubantu一样 终端的使用 图形终端 命令行终端 远程终端（SSH VNC） 通过互联网远程连接终端，实际生产使用较多 Linux常见目录介绍 / 根目录 /root root用户的家目录 /home/username 普通用户的家目录 /etc 配置文件目录 /bin 命令目录 /sbin 管理命令目录 /usr/bin /usr/sbin 系统预装的其他命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"overview","slug":"overview","permalink":"https://jjw-story.github.io/tags/overview/"}],"author":"JJW"}]}