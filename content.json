{"meta":{"title":"JJW-STORY","subtitle":null,"description":null,"author":"JJW","url":"https://jjw-story.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-06T09:23:47.544Z","updated":"2019-07-06T09:23:47.544Z","comments":true,"path":"about/index.html","permalink":"https://jjw-story.github.io/about/index.html","excerpt":"","text":"关于我北京车和家信息技术有限公司~~开发工程师 关于工作城市：北京 关于学习每天都走在学习的大路上 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好杂乱无章 联系我 Home: JJW-STORE.GITHUB.IO Blog: JJW-STORE.GITHUB.IO Email: CHINAGOLDWJ@163.COM GitHub: JJW-STORE WeiBo: JJWStrive"}],"posts":[{"title":"网络配置","slug":"网络配置","date":"2019-08-12T12:00:00.000Z","updated":"2019-08-24T11:24:45.459Z","comments":true,"path":"2019/08/12/网络配置/","link":"","permalink":"https://jjw-story.github.io/2019/08/12/网络配置/","excerpt":"","text":"网络配置命令设置网卡IP地址ifconfig命令我们可以使用ifconfig命令来设置网卡的ip地址，使用方法: ifconfig 接口 IP地址 [netmask 子网掩码] 使用示例： 123456789101112131415161718192021222324root@CHJ-20190520VPS:/# ifconfigeth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.113 netmask 255.255.255.240 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) ...# 修改iproot@CHJ-20190520VPS:/# ifconfig eth3 172.31.34.118root@CHJ-20190520VPS:/# ifconfigeth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.113 netmask 255.255.255.240 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) ...# 修改ip并指定子网掩码root@CHJ-20190520VPS:/# ifconfig eth3 172.31.34.118 netmask 255.255.255.0root@CHJ-20190520VPS:/# ifconfigeth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.118 netmask 255.255.255.0 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) ... 启动和关闭网卡启动和关闭网卡动作和我们Windows中的是一样的，这两个操作其实是在一些特殊情况来使用网卡操作的命令，一般是网卡的配置被改乱了，我们希望恢复到默认的配置，可能需要这两个命令，一般情况下我们是不需要使用这两个命令的 启动命令以下都分别对用两种工具包的命令，使用哪一种都可以 ifconfig 接口 up ifup 接口 关闭命令ipconfig 接口 down ifdown 接口 网关配置命令添加网关网段使用route add命令，使用方法： route add [-net | -host] 目的网络或主机 gw 网关ip route add [-net | -host] dev 网卡接口 route add -net 指定网段 netmask 子网掩码 eth0 route add -net 指定网段 netmask 子网掩码 gw 网关ip -net是指定网段，-host是指定ip 使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 添加主机路由[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route add -host 192.168.1.2 dev eth0[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.2 * 255.255.255.255 UH 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 添加网络路由 10.20.30.40 ~ 255.255.255.248[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route add -net 10.20.30.40 netmask 255.255.255.248 eth0[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.2 * 255.255.255.255 UH 0 0 0 eth010.20.30.40 * 255.255.255.248 U 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 添加默认路由 default ~ 192.168.1.2[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route add default gw 192.168.1.2[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.2 * 255.255.255.255 UH 0 0 0 eth010.20.30.40 * 255.255.255.248 U 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 192.168.1.2 0.0.0.0 UG 0 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0 删除网关网段使用route del命令，使用方法： route del [-net | -host] 目的网络或主机 gw 网关ip route del [-net | -host] dev 网卡接口 route del -net 指定网段 netmask 子网掩码 eth0 route del -net 指定网段 netmask 子网掩码 gw 网关ip 使用示例： 123456789101112131415161718192021222324252627282930313233343536373839[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.2 * 255.255.255.255 UH 0 0 0 eth010.20.30.40 * 255.255.255.248 U 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 192.168.1.2 0.0.0.0 UG 0 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 删除主机路由[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route del -host 192.168.1.2 dev eth0[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface10.20.30.40 * 255.255.255.248 U 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 192.168.1.2 0.0.0.0 UG 0 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 删除默认路由[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route del -net default gw 192.168.1.2[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface10.20.30.40 * 255.255.255.248 U 0 0 0 eth0172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0# 删除网络路由[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route del -net 10.20.30.40 netmask 255.255.255.248 eth0[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"网络管理","slug":"网络管理","permalink":"https://jjw-story.github.io/tags/网络管理/"}],"author":"JJW"},{"title":"Djongo-03","slug":"Djongo-03","date":"2019-08-11T05:30:43.000Z","updated":"2019-08-11T12:01:02.866Z","comments":true,"path":"2019/08/11/Djongo-03/","link":"","permalink":"https://jjw-story.github.io/2019/08/11/Djongo-03/","excerpt":"","text":"通用视图通用视图介绍通用视图把视图开发中常用的写法和模式抽象出来，让你编写少量代码就能快速实现常见的数据视图。显示对象列表就是这样一种任务。 有了通用视图，可以把模型作为额外的参数传给 URL 配置。Django 自带的通用视图能实现下述功能： 列出对象并显示单个对象的详细信息。如果创建一个管理会议的应用程序，那么TalkListView 和RegisteredUserListView就是列表视图。某一个演讲的页面就是详细信息视图。 呈现基于日期的对象，显示为年月日归档页面（带有详细信息），以及“最新”页面。 让用户创建、更新和删除对象——需不需要授权都行。 具体使用示例及说明示例展示的是一个查询出所有厂家及根据URl中传入的厂家名称查询出此厂家生产的所有商品的示例： 视图函数如下(在项目view.py下定义)： 12345678910111213141516171819202122232425262728293031323334353637from cerealsOils.models import Manufacturers, Productfrom django.views.generic import ListViewfrom django.shortcuts import get_object_or_404# Create your views here.# 定义通用视图class ManufacturersList(ListView): # 注意此行代码表示：其实是queryset = Publisher.objects.all() 的简洁形式。 # model = Manufacturers # 动态过滤 # 根据 URL 中指定的键过滤列表页面中的对象 # 我们可以覆盖ListView 的 get_queryset() 方法。它的默认实现是返回queryset 属性的值，不过我们可以添加更多逻辑 # 这里根据url中传入的厂家名称，过滤出指定厂家生产的产品 def get_queryset(self): # 获取到GET请求捕获到的参数 self.manu = get_object_or_404(Manufacturers, name=self.args[0]) # 过滤 return Product.objects.filter(manufacturers=self.manu) # 提供“友好的”模板上下文，如果我们不自已定义模板上下文名称，默认会将上述查询结果存储在名为 object_list 的变量中 # 现在我们将它存储在 manu_list 变量中 context_object_name = &quot;product_list&quot; # 自定义了模板名称，既指定使用的模板 # 如果没明确指定，Django 将从对象的名称中推知。这里，推知的模板是cerealsOils/manufacturers_list.html template_name = &apos;manu_list.html&apos; # 提供额外的上下文变量 # 就是扩展DetailView，自己实现get_context_data 方法，然后在此方法提供额外的数据 # 这里查询出所有的厂家返回给页面 def get_context_data(self, **kwargs): # 先调用原来的实现，获取上下文 context = super(ManufacturersList, self).get_context_data(**kwargs) # 查询出所有的产品 context[&apos;manu_list&apos;] = Manufacturers.objects.all() return context url定义如下： 1234urlpatterns = [ # 注意 as_view() 函数 url(r&apos;^manulist/([\\w-]+)$&apos;, views.ManufacturersList.as_view())] 模板代码如下： 1234567891011121314151617181920&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&apos;UTF-8&apos;&gt; &lt;title&gt;通用视图测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;厂家名称&lt;/h1&gt; &#123;% for manu in manu_list %&#125; &lt;li&gt;&#123;&#123; manu.name &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;hr&gt; &lt;h1&gt;产品名称&lt;/h1&gt; &#123;% for prod in product_list %&#125; &lt;li&gt;&#123;&#123; prod.title &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;hr&gt; &lt;p&gt;谢谢光临&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 以上便是通用视图的实现，是不是很方便呢！","categories":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://jjw-story.github.io/tags/Django/"}],"author":"JJW"},{"title":"网络状态查看","slug":"网络状态查看","date":"2019-08-08T12:20:20.000Z","updated":"2019-08-03T11:13:31.476Z","comments":true,"path":"2019/08/08/网络状态查看/","link":"","permalink":"https://jjw-story.github.io/2019/08/08/网络状态查看/","excerpt":"","text":"网络状态查看网络状态查看我们列举两套工具包，一套是net-tools，一套是iproute或者有时候也叫iproute2 使用两套工具的作用是，在CentOS7以前，我们一般使用的都是net-tools工具包，而在CentOS7以后，主推的使用iproute工具包 ifconfig查看网络状态既网卡状态，使用方法：ifconfig [网卡名称] 注意网卡名称是可选的，管理用户直接输入命令，普通用户需要 /sbin/ifconfig(注意普通用户需要加上命令的完整路径) 一般使用此命令查询出来的结果中，会显示etho，第一块网卡的状态信息，这个名字是默认的，但是有可能我们查询出来不叫这个名字，这是因为在CentOS7中使用了一致性网络设备命名，它会先去检测我们的网卡，检测后具体命名如下： en01 板载网卡 ens33 PCI-E网卡 enp0s3 无法获取物理信息的PCI-E网卡 eth0 如果以上都获取不到，会使用此命名 使用示例： 123456789101112131415161718wangjia3@CHJ-20190520VPS:~$ ifconfigeth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.113 netmask 255.255.255.240 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 1500 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x0&lt;global&gt; loop (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们还可以使用命令：ifconfig 网卡名称 来查看指定网卡，例如我们只查看lo网卡的信息： 以上查询结果我们需要关注的是： etho信息中的 inet选项，第一个参数addr是IP信息，Mask参数对应的是子网掩码，还要注意 有个 ether参数，它显示的是mac地址，RX、TX：发送数据包的个数及多少 lo网卡信息中：lo网卡表示的是本地环回，它的地址永远是127.0.0.1，这个网卡的作用就是我们在自己本地搭建了一个服务，在我们访问自己主机服务的时候，就使用这个IP 123456789wangjia3@CHJ-20190520VPS:~$ ifconfig lolo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 1500 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x0&lt;global&gt; loop (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 修改网卡名称有时候我们在管理Linux网卡的时候，可能会有很多机器，我们需要写一个通用的脚本来修改，但是我们多个机器的网卡名称不一样，那么我们就需要手动的修改网卡的名称，来保证多个机器的网卡名称保持一致，这样能便于管理，下面我们介绍的就是修改网卡名称的方法，分为两步： 第一步： 网卡命名规则受 biosdevname和net.ifnames两个参数影响，这两个参数我们需要编辑 /etc/defult/grub 文件来修改，为此文件增加如下两个参数： biosdevname=0 net.ifnames=0 第二步： 更新grup，上述编辑好的文件并不会在系统启动的时候被读取到，所以我们需要将上述文件转化为系统启动可读取的文件，使用命令： grub2-mkconfig -o /boot/grup2/grup.cfg 第三步： 重启，重启命令是reboot，重启完成之后，网卡名称就变成了 eth0 biosdevname和net.ifnames组合明细： 序列 biosdevname net.ifnames 网卡名 默认 0 1 ens33 组合1 1 0 em1 组合2 0 0 eth0 查看网卡物理连接情况查看网卡物理连接情况，比如查看网线是否连接好，Windows可以直接通过图形界面来查看，Linux需要用过命令来查看 mii-tool命令 使用方法：mii-tool [网卡名称] 注意CentOS7及以上使用此命令，网卡名称是必须要有的 12345678910111213141516root@CHJ-20190520VPS:/# mii-toolNo interface specifiedusage: mii-tool [-VvRrwl] [-A media,... | -F media] [-p addr] &lt;interface ...&gt; -V, --version display version information -v, --verbose more verbose output -R, --reset reset MII to poweron state -r, --restart restart autonegotiation -w, --watch monitor for link status changes -l, --log with -w, write events to syslog -A, --advertise=media,... advertise only specified media -F, --force=media force specified media technology -p, --phy=addr set PHY (MII address) to reportmedia: 1000baseTx-HD, 1000baseTx-FD, 100baseT4, 100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD, (to advertise both HD and FD) 1000baseTx, 100baseTx, 10base 也可以使用：ethtool命令 使用方法：ethtool 网卡名称 123[root@iZm5ehzqow4ijp2ya2g2drZ etc]# ethtool eth0Settings for eth0: Link detected: ye 查看网关命令当我们机器需要网络通信的时候，需要连接其它的网络地址范围的时候，我们就需要配置网关，也叫配置路由 使用route命令来查看网关，使用方法：route [参数] 参数：-n 如果我们单独只用route命令时，默认使用时每一个IP都会反解成主机名，这个过程很慢，所以可以使用此参数可以不解析主机名 使用示例： 12345678910111213[root@iZm5ehzqow4ijp2ya2g2drZ etc]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface172.31.240.0 * 255.255.240.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 172.31.255.253 0.0.0.0 UG 0 0 0 eth0[root@iZm5ehzqow4ijp2ya2g2drZ etc]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface172.31.240.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth00.0.0.0 172.31.255.253 0.0.0.0 UG 0 0 0 eth0 输出项说明： 输出项 说明 Destination 目标网段或者主机 Gateway 网关地址，”*” 表示目标是本主机所属的网络，不需要路由 Genmask 网络掩码 Flags 标记。一些可能的标记如下： - U — 路由是活动的 - H — 目标是一个主机 - G — 路由指向默认网关 - R — 恢复动态路由产生的表项 - D — 由路由的后台程序动态地安装 - M — 由路由的后台程序修改 - ! — 拒绝路由 Metric 路由距离，到达指定网络所需的中转数（linux 内核中没有使用） Ref 路由项引用次数（linux 内核中没有使用） Use 此路由项被路由软件查找的次数 Iface 该路由表项对应的输出接口 主机路由：主机路由是路由选择表中指向单个IP地址或主机名的路由记录。主机路由的Flags字段为H。例如，在下面的示例中，本地主机通过IP地址192.168.1.1的路由器到达IP地址为10.0.0.10的主机 12Destination Gateway Genmask Flags Metric Ref Use Iface10.0.0.10 192.168.1.1 255.255.240.0 UH 0 0 0 eth0 网络路由：网络路由是代表主机可以到达的网络。网络路由的Flags字段为N。例如，在下面的示例中，本地主机将发送到网络192.19.12.20的数据包转发到IP地址为192.168.1.1的路由器 12Destination Gateway Genmask Flags Metric Ref Use Iface192.19.12.20 192.168.1.1 255.255.240.0 UN 0 0 0 eth0 默认路由：当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的Flags字段为G。例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器 12Destination Gateway Genmask Flags Metric Ref Use Ifacedefault 192.168.1.1 0.0.0.0 UG 0 0 0 eth0","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"网络管理","slug":"网络管理","permalink":"https://jjw-story.github.io/tags/网络管理/"}],"author":"JJW"},{"title":"Django-01","slug":"Django-01","date":"2019-08-04T02:31:02.000Z","updated":"2019-08-05T09:23:05.959Z","comments":true,"path":"2019/08/04/Django-01/","link":"","permalink":"https://jjw-story.github.io/2019/08/04/Django-01/","excerpt":"","text":"Djongo入门Djongo介绍Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。 Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式，各自职责如下： 层次 职责 模型（Model），即数据存取层 处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。 模板(Template)，即表现层 处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 视图（View），即业务逻辑层 存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁 Django 框架的核心组件及设计哲学： 对象关系映射 (ORM,object-relational mapping)：以Python类形式定义你的数据模型，ORM将模型与关系数据库连接起来，你将得到一个非常容易使用的数据库API，同时你也可以在Django中使用原始的SQL语句。 URL 分派：使用正则表达式匹配URL，你可以设计任意的URL，没有框架的特定限定。像你喜欢的一样灵活。 模版系统：使用Django强大而可扩展的模板语言，可以分隔设计、内容和Python代码。并且具有可继承性。 表单处理：你可以方便的生成各种表单模型，实现表单的有效性检验。可以方便的从你定义的模型实例生成相应的表单。 Cache系统：可以挂在内存缓冲或其它的框架实现超级缓冲 －－ 实现你所需要的粒度。 会话(session)，用户登录与权限检查，快速开发用户会话功能。 国际化：内置国际化系统，方便开发出多种语言的网站。 自动化的管理界面：不需要你花大量的工作来创建人员管理和更新内容。Django自带一个ADMIN site,类似于内容管理系统 Djongo安装Djongo安装分为三步： 安装 Python 安装 Python 虚拟环境 安装 Django 第一步不在赘述，注意使用Python3及以上版本 第二步安装虚拟环境的目的是为了解决电脑中的软件相互依赖，每个程序都要依赖某些其他程序，而且要找到运行其他软件的设置（环境变量），编写新软件程序时，可能（经常）要修改其他软件所需的依赖或环境变量，这一步可能会导致各种问题，因此要避免。 Python 虚拟环境能解决这个问题。它把软件所需的全部依赖和环境变量包装到一个文件系统中，与电脑中的其他软件隔离开。 直接使用命令：pip install virtualenv 即可安装完成。 安装完成后执行命令：virtualenv env_mysite为我们自己的项目创建虚拟环境，注意env_mysite可以自定义，执行完成后我们发现在我们电脑家目录下就创建好了一个 \\env_mysite 的文件夹，virtualenv 创建了一个完整的 Python 安装，它与其他软件是隔离开的，因此开发项目时不会影响系统中的其他软件。 我们需要激活此虚拟环境，使用命令：env_mysite\\scripts\\activate，激活后我们就可以使用此虚拟环境。 第三步安装Djongo，直接在虚拟环境下执行命令：pip install django==1.8.13，即可安装Djongo1.8.13版本完成 新建Djongo项目在虚拟环境中执行django-admin startproject mysite，如果不使用虚拟环境，也可以自己找到项目位置，执行此命令创建项目。命令执行完成后我们看到Djongo为我们创建了如下文件： 1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 外层的mysite/ 根目录是项目的容器。这个目录的名称对 Django 没有什么作用，你可以根据喜好重命名。 manage.py 是一个命令行实用脚本，可以通过不同的方式与 Django 项目交互。 内部的mysite/ 目录是项目的 Python 包。导入这里面的内容时要使用目录的名称（如mysite.urls）。 mysite/init.py 是一个空文件，目的是让 Python 把这个目录识别为 Python 包。 mysite/settings.py 是 Django 项目的设置/配置。 mysite/urls.py 是 Django 项目的 URL 声明，即 Django 驱动的网站的“目录”。 mysite/wsgi.py 是兼容 WSGI 的 Web 服务器的入口点，用于伺服项目。 这里说明一下settings文件，这是整个项目的配置和设置，我们发现Djongo框架本身已经帮我们创建好了一些项目，这是为常见场景所做的约定，具体看INSTALLED_APPS的配置（这里打开项目为大家讲解一下此文件的配置内容）： 1234567891011# Application definition# 注意：此处添加自己开发的应用INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, # 管理后天 &apos;django.contrib.auth&apos;, # 身份验证系统 &apos;django.contrib.contenttypes&apos;, # 内容类型框架 &apos;django.contrib.sessions&apos;, # 会话框架 &apos;django.contrib.messages&apos;, # 消息框架 &apos;django.contrib.staticfiles&apos;, # 管理静态文件的框架 &apos;cerealsOils&apos;, # 自己开发的应用) 使用这些项目我们需要在数据库中创建这些项目所需的表，执行命令即可自动创建：python manage.py migratehibernate框架，通过实体类上使用注解，自动创建表。 这样我们的项目就创建完成了，使用命令：python manage.py runserver 就可以启动项目啦，默认端口为8000，我们访问就可以看到主页了。 视图和URl配置创建视图函数创建视图需要在项目目录下新创建一个view.py文件，此文件中我们定义函数，返回给视图我们要展示的内容，如下： 12345678910111213141516171819202122232425# 从django.http 模块中导入HttpResponse 类。导入这个类是因为后面的代码要使用from django.http import HttpResponse# 视图函数，传入参数：jango.http.HttpRequest对象实例，注意此参数是视图函数必须的且是第一位的参数# 静态内容def hello(request): # 返回 Hello World 给response return HttpResponse(&quot;Hello World&quot;)# 动态内容def currentDatetime(request): now = datetime.datetime.now() html = &quot;现在时间： % now return HttpResponse(html)# 动态urldef timeAhead(request, offset): try: offset = int(offset) except ValueError: # 如果传给int() 函数的值不能转换成整数（如字符串&quot;foo&quot;），Python 会抛出ValueError 异常 raise Http404() dt = datetime.datetime.now() + datetime.timedelta(hours=offset) html = &quot;In %s hour(s), it will be %s.&quot; % (offset, dt) return HttpResponse(html) 配置URl若想把视图函数与特定的 URL 对应起来，要使用 URL 配置（URLconf）。URL 配置相当于 Django 驱动的网站的目录。简单来说，URL 配置把 URL 映射到相应的视图函数上，具体配置及说明如下： 12345678910111213141516171819# 从django.conf.urls 模块中导入两个函数：include，用于导入另一个 URL 配置模块；url，使用正则表达式模式匹配浏览器中的 URL，把它映射到 Django 项目中的某个模块上。from django.conf.urls import include, url# 从django.contrib 模块中导入admin 函数。这个函数传给include 函数，加载 Django 管理后台的 URLfrom django.contrib import admin# url实例列表urlpatterns = [ # 注意：正则表达式字符串前面的&apos;r&apos; 字符。它的目的是告诉 Python，那是“原始字符串”，不要解释里面的反斜线 # 第一个参数是模式匹配字符串（一个正则表达式，稍后说明），第二个参数是模式使用的视图函数 # url(r&apos;^$&apos;, index), # 为根地址指定一个 URL 模式 url(r&apos;^admin/&apos;, include(admin.site.urls)), # 静态类容 url(r&apos;^hello/$&apos;, hello), # ^ 和 $ 开头和结尾匹配模式 去掉hello就可以作为根地址 # 动态内容 url(r&apos;^nowTime/$&apos;, currentDatetime), # 动态URl，Django 的核心哲学之一是，URL 应该美观，既符合REST风格，这里能匹配time/plus/2 time/plus/20 url(r&apos;^time/plus/(\\d&#123;1,2&#125;)/$&apos;, timeAhead), # 正则匹配] 处理请求过程运行python manage.py runserver 命令时，manage.py 脚本在内层mysite 目录中寻找名为settings.py 的文件。这个文件中保存着当前 Django 项目的全部配置，各个配置的名称都是大写的，然后找到如下配置： 12# 指向URl配置文件，寻找URl详细配置ROOT_URLCONF = &apos;mysite.urls&apos; 找到匹配的模式之后，调用对应的视图函数，并把一个HttpRequest 对象作为第一个参数传给视图,视图函数必须返回一个HttpResponse 对象。 随后，余下的工作交给 Django 处理：把那个 Python 对象转换成正确的 Web 响应，并且提供合适的 HTTP 首部和主体（即网页的内容）。综上： 请求/hello/。 Django 查看ROOT_URLCONF 设置，找到根 URL 配置。 Django 比较 URL 配置中的各个 URL 模式，找到与/hello/ 匹配的那个。 如果找到匹配的模式，调用对应的视图函数。 视图函数返回一个HttpResponse 对象。 Django 把HttpResponse 对象转换成正确的 HTTP 响应，得到网页。 Djongo模板Django 模板是一些文本字符串，作用是把文档的表现与数据区分开。模板定义一些占位符和基本的逻辑（模板标签），规定如何显示文档。通常，模板用于生成 HTML，不过 Django 模板可以生成任何基于文本的格式。 变量和模板标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141* &#123;&#123; xxx &#125;&#125; 指定变量的值插入这里* &#123;% xxx %&#125; 模板标签，基本模板标签有如下 # 逻辑判断标签 # 注意，此示例中使用了 if elif else and not or 等逻辑判断语句，与python保持一致 # if标签中不能包含括号，如果需要使用括号判断，必须写成嵌套 if 标签语句 &#123;% if a1 and a2 %&#125; &lt;p&gt;a1为真并且a2为真，显示此内容&lt;/p&gt; &#123;% elif not a3 %&#125; &lt;p&gt; else if a3 为假，显示此内容，注意elif是可选标签&lt;/p&gt; &#123;% elif a4 or not a5 %&#125; &lt;p&gt; else if a4 为真，或者 a5 为假，显示此内容，注意elif是可选标签&lt;/p&gt; &#123;% else %&#125; &lt;p&gt; else显示此内容，注意else是可选标签&lt;/p&gt; &#123;% endif %&#125; # 迭代元素标签 # 正向迭代 &#123;% for item in item_list %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; # 反向迭代 &#123;% for item in item_list reversed %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; # 定义迭代列表为空的行为 &#123;% for item in item_list %&#125; &lt;p&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; &#123;% empty %&#125; &lt;p&gt;此处定义要迭代的元素为空的行为&lt;/p&gt; &#123;% endfor %&#125; # 获取迭代当前元素索引 &#123;% for item in item_list %&#125; &lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: forloop.counter表示当前元素索引&lt;/p&gt; &lt;p&gt;&#123;&#123; forloop.revcounter &#125;&#125;: forloop.revcounter表示剩余元素数量&lt;/p&gt; &#123;% if forloop.first %&#125; &lt;p&gt;forloop.first返回的是boolean，表示是否第一个元素&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;forloop.last返回的也是boolean，表示是否最后一个元素&lt;/p&gt; &#123;% endif %&#125; &#123;% endfor %&#125; # 比较值相等标签 &#123;% ifequal A B %&#125; &lt;h1&gt;A 的值和 B 的值相等!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;A 的值和 B 的值不相等!&lt;/h1&gt; &#123;% endifequal %&#125; # 比较值不相等标签 &#123;% ifnotequal A &apos;JJW&apos; %&#125; &lt;h1&gt;A 的值不等于JJW!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;A 的值等于JJW!&lt;/h1&gt; &#123;% endifnotequal %&#125; # 模板注释 # 单行注释 &#123;# 这里是一个注释 #&#125; # 多行注释，comment标签 &#123;% comment %&#125; 第一行注释 第二行注释 &#123;% endcomment %&#125; # 过滤器 # 模板过滤器是在显示变量之前调整变量值的简单方式 # 把文本转换成小写，然后再显示 &#123;&#123; name|lower &#125;&#125; # 获取列表中的第一个元素，然后将其转换成大写 &#123;&#123; my_list|first|upper &#125;&#125; # 显示bio 变量的前 30 个词 &#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125; # 在反斜线、单引号和双引号前面添加一个反斜线。可用于转义字符串 &#123;&#123; value|addslashes &#125;&#125; # 返回值长度，如果是列表，返回列表元素个数 &#123;&#123; name|length &#125;&#125; # include 模板标签 这个标签的作用是引入另一个模板的内容。它的参数是要引入的模板的名称，可以是变量，也可以是硬编码的字符串（放在引号里，单双引号都行） &#123;% include &apos;nav.html&apos; %&#125; &#123;% include &quot;nav.html&quot; %&#125; # 以下是使用示例 &lt;html&gt; &lt;body&gt; &#123;% include &quot;includes/nav.html&quot; %&#125; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; # includes/nav.html &lt;div id=&quot;nav&quot;&gt; You are in: &#123;&#123; current_section &#125;&#125; &lt;/div&gt; # 模板继承 # 模板继承是指创建一个基底“骨架”模板，包含网站的所有通用部分，并且定义一些“块”，让子模板覆盖。 # 首先定义一个基地模板 # &#123;% block xxx %&#125;&#123;% endblock %&#125; 表示此标签内容可以被子模板重写 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My helpful timestamp site&lt;/h1&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &#123;% block footer %&#125; &lt;hr&gt; &lt;p&gt;Thanks for visiting my site.&lt;/p&gt; &#123;% endblock %&#125; &lt;/body&gt; &lt;/html&gt; # 然后定义子模板 # 子模板需要继承父模板 &#123;% extends &quot;base.html&quot; %&#125; # 重写依然要使用 &#123;% block xxx %&#125;&#123;% endblock %&#125; 标签 &#123;% extends &quot;base.html&quot; %&#125; &#123;% block title %&#125;Future time&#123;% endblock %&#125; &#123;% block content %&#125; &lt;p&gt; In &#123;&#123; hour_offset &#125;&#125; hour(s), it will be &#123;&#123; next_time &#125;&#125;. &lt;/p&gt; &#123;% endblock %&#125; 使用模板系统Django 系统经过配置后可以使用一个或多个模板引擎（如果不用模板，那就不用配置）。Django 自带了一个内置的后端，用于支持自身的模板引擎，即 Django Template Language（DTL），若想在 Python 代码中使用 Django 的模板系统，基本方式如下： 以字符串形式提供原始的模板代码，创建Template 对象。 在Template 对象上调用render() 方法，传入一系列变量（上下文）。返回的是完全渲染模板后得到的字符串，模板中的变量和模板标签已经根据上下文求出值了。 以上步骤我们都可以使用一个函数来完成，那就是render()函数，render() 的第一个参数是请求对象，第二个参数是模板名称，第三个参数可选，是一个字段，用于创建传给模板的上下文。如果不指定第三个参数，render() 使用一个空字典，具体使用如下介绍。 模板目录及模板加载为了从文件系统中加载模板，Django 提供了便利而强大的 API，力求去掉模板加载调用和模板自身的冗余。若想使用这个模板加载 API，首先要告诉框架模板的存储位置。这个位置在设置文件中配置，打开settings.py 文件，找到TEMPLATES 设置。它的值是一个列表，分别针对各个模板引擎： 123456789101112131415161718192021222324TEMPLATES = [ &#123; # BACKEND 的值是一个点分 Python 路径，指向实现 Django 模板后端 API 的模板引擎类 &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, # DIRS 定义一个目录列表，模板引擎按顺序在里面查找模板源文件。 # 当前设置表示在项目根目录中放一些主模板，模板目录不一定非得叫&apos;templates&apos;，可以自定义 &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], # 去应用所在位置查找模板，APPS_DIRS 设为True 时，DjangoTemplates 会在INSTALLED_APPS 中的各个应用里查找名为“templates”的子目录。这样，即使DIRS 为空，模板引擎还能查找应用模板。 &apos;APP_DIRS&apos;: True, # OPTIONS 是一些针对后端的设置 &apos;OPTIONS&apos;: &#123; # 默认的处理器上下文 &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 查找模板逻辑 如果APP_DIRS 的值是True，而且使用 DTL，在当前应用中查找“templates”目录。 如果在当前应用中没找到模板，把传给它的模板名称添加到DIRS 中的各个目录后面，按顺序在各个目录中查找。假如DIRS 的第一个元素是’/home/django/mysite/templates’，调用查找的模板是/home/django/mysite/templates/current_datetime.html。 找不到指定名称对应的模板，抛出TemplateDoesNotExist 异常。 使用示例及说明视图函数如下定义： 123456from django.shortcuts import renderimport datetimedef currentDatetime(request): now = datetime.datetime.now() return render(request, &apos;test/current_datetime.html&apos;, &#123;&apos;current_date&apos;: now&#125;) 通过以上示例我们发现： 不用再导入get_template、Template、Context 或HttpResponse 了，而要导入django.shortcuts.render import datetime 不变。 在current_datetime 函数中，仍然要计算now，不过加载模板、创建上下文、渲染模板和创建HttpResponse对象全由render() 调用代替了。render() 的返回值是一个HttpResponse 对象，因此在视图中可以直接返回那个值。 注意上述我们还使用了模板子目录：test/current_datetime.html，表示去根目录下寻找templates目录下的test目录，找到模板。 Djongo模型Django 非常适合构建数据库驱动型网站，它提供了简单而强大的工具，易于使用 Python 执行数据库查询，本章就说明这个功能，即 Django 的数据库层。 配置数据库数据库连接的配置也在settings文件中，具体如下： 1234567891011121314151617181920# 数据库配置，这里使用集成的sqllite3，我们配置自己的数据库，类似于我们Java项目中的配置文件中配置即可DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, # ENGINE 告诉 Django 使用哪个数据库引擎。 &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), # NAME 告诉 Django 数据库的名称。 &#125;&#125;# 配置MySQL数据库# DATABASES = &#123;# &apos;default&apos;: &#123;# &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, # 或者使用 mysql.connector.django# &apos;NAME&apos;: &apos;test&apos;,# &apos;USER&apos;: &apos;test&apos;,# &apos;PASSWORD&apos;: &apos;test123&apos;,# &apos;HOST&apos;:&apos;localhost&apos;,# &apos;PORT&apos;:&apos;3306&apos;,# &#125;# &#125; 创建应用下面说明项目和应用的区别： 一个项目是一系列 Django 应用的实例，外加那些应用的配置。严格来说，一个项目唯一需要的是一个设定文件，定义数据库连接信息、安装的应用列表、DIRS，等等。 一个应用是一系列便携的 Django 功能，通常包含模型和视图。打包在一个 Python 包里。Django 自带了一些应用，例如管理后台。这些应用的独特之处是便携，可以在多个项目中复用。 在项目目录，注意是项目目录，使用如下命令创建新的应用，并指定自定义应用名称：python manage.py startapp 应用名称。 Django 通过模型在背后执行 SQL，返回便利的 Python 数据结构，表示数据库表中的行。Django 还通过模型表示 SQL 无法处理的高层级概念，这么做的好处如下： 内省（introspection）有开销，而且不完美。为了提供便利的数据访问 API，Django 需要以某种方式知晓数据库布局，而这一需求有两种实现方式。第一种是使用Python 明确描述数据，第二种是在运行时内省数据库，推知数据模型。第二种方式在一个地方存储表的元数据，看似更简单，其实会导致几个问题。首先，运行时内省数据库肯定有消耗。如果每次执行请求，或者只是初始化 Web 服务器都要内省数据库，那带来的消耗是无法接受的，其次，有些数据库，尤其是旧版 MySQL，存储的元数据不足以完成内省。 Python 编写起来让人心情舒畅，而且使用 Python 编写所有代码无需频繁让大脑切换情境。在一个编程环境（思维）中待久了，有助于提升效率。在 SQL 和 Python 之间换来换去容易打断状态。 把数据模型保存在代码中比保存在数据库中易于做版本控制，易于跟踪数据布局的变化。 SQL 对数据布局的元数据只有部分支持。例如，多数数据库系统没有提供专门表示电子邮件地址或URL 的数据类型。而 Django 模型有。高层级的数据结构有助于提升效率，让代码更便于复用。 不同数据库平台使用的 SQL 不一致。 分发 Web 应用程序时，更务实的做法是分发一个描述数据布局的 Python 模块，而不是分别针对MySQL、PostgreSQL 和 SQLite 的CREATE TABLE 语句。 创建自己的模型在我们新创建的应用的models.py文件中，添加自己定义的模型，如下： 让 Django 具有基本的数据访问能力只需编写这些代码。一般，一个模型对应于一个数据库表，模型中的各个属性分别对应于数据库表中的一列。属性的名称对应于列的名称，字段的类型（如CharField）对应于数据库列的类型(如varchar) 123456789101112131415161718192021222324252627282930313233343536# 厂家class Manufacturers(models.Model): name = models.CharField(max_length=30) address = models.CharField(max_length=50) city = models.CharField(max_length=60) province = models.CharField(max_length=30) website = models.URLField(blank=True, null=True, verbose_name=&apos;网址&apos;) # 表单允许为空 修改数据库结构，表示字段可为空 def __str__(self): return u&apos;%s&apos; % (self.name)# 经销商class Vender(models.Model): name = models.CharField(max_length=30) address = models.CharField(max_length=50) city = models.CharField(max_length=60) province = models.CharField(max_length=30) telephone = models.CharField(max_length=20) def __str__(self): return u&apos;%s %s %s %s %s&apos; % (self.name, self.address, self.city, self.province, self.telephone)# 产品class Product(models.Model): title = models.CharField(max_length=100) vender = models.ManyToManyField(Vender) # 多对多关系 manufacturers = models.ForeignKey(Manufacturers) # 一对多 product_date = models.DateField() # fields = (&apos;title&apos;, &apos;product_date&apos;, &apos;vender&apos;, &apos;manufacturers&apos;) def __str__(self): return u&apos;%s %s&apos; % (self.title, self.product_date) # 任何模型都可以使用Meta 类指定多个针对所在模型的选项。 class Meta: ordering = [&apos;product_date&apos;] 注意：多对多关系，在上述示例模型中，Django 会创建一个额外的表，一个多对多联结表（join table），处理Product与Vender之间的对应关系。 安装模型在settings文件中注册上我们自己创建的应用，注册位置已经在之前描述过，如下： 123456789101112# Application definition# 注意：此处添加自己开发的应用INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, # 管理后台 &apos;django.contrib.auth&apos;, # 身份验证系统 &apos;django.contrib.contenttypes&apos;, # 内容类型框架 &apos;django.contrib.sessions&apos;, # 会话框架 &apos;django.contrib.messages&apos;, # 消息框架 &apos;django.contrib.staticfiles&apos;, # 管理静态文件的框架 &apos;cerealsOils&apos;, # 自己开发的应用) 注册好后就可以验证和安装模型： 验证模型使用命令：python manage.py check check 命令运行 Django 系统检查框架，即验证 Django 项目的一系列静态检查。如果一切正常，你将看到这个消息：System check identified no issues (0 silenced)，不然会抛出出错位置的异常 安装模型使用命令：python manage.py makemigrations cerealsOils，这样我们就安装好了模型，并根据模型定义创建好了数据库表 查看建表语句可以执行命令：python manage.py sqlmigrate cerealsOils 0001，这样建表语句就会输出出来 Djongo后台管理对多数现代的网站而言，管理界面是基础设施的重要组成部分。这是一个 Web 界面，限制只让授信的网站管理员访问，用于添加、编辑和删除网站内容。常见的示例有：发布博客的界面，网站管理人员审核用户评论的后端，客户用来更新新闻稿的工具。不过，管理界面有个问题：构建起来繁琐。构建面向公众的功能时，Web 开发是有趣的，但是管理界面一成不变，要验证用户身份、显示并处理表单、验证输入，等等。这个过程无趣、乏味。在 Django 中，构建管理界面不算个事， Django 为我们自动生成的管理界面，了解它为模型提供的便利界面，以及可以使用的其他功能。 使用管理后台之前创建项目时我们执行了django-admin startproject mysite命令时，Django 为我们创建并配置了默认的管理后台。我们只需创建一个管理员用户（超级用户），就可以登录管理后台。 创建管理用户：python manage.py createsuperuser 输入要创建的用户：Username: admin 输入邮箱地址：Email address: admin@example.com 输入用户密码，需要输入两次确认：Password: ** 启动服务器，访问ttp://127.0.0.1:8000/admin/就可以进入登录页面，登录后具体操作就可以被看懂了，这里不再赘述，可以启动项目为大家演示一下。 将我们创建的模型添加至后台管理在我们新创建的项目目录下创建admin.py文件，并添加如下代码，这样就将我们创建的模型添加至了后天管理系统： 1234567from django.contrib import adminfrom .models import Manufacturers, Vender, Product# 注册我们创建的模型admin.site.register(Manufacturers, ManufacturersAdmin)admin.site.register(Vender, VenderAdmin)admin.site.register(Product, ProductAdmin) 将字段定义为可选（非必填）及自定义字段标注默认我们创建的模型在后台管理页面都是必填字段，及显示的名称都是字段的英文名称，我们可以修改model，添加一下属性，来设置字段为非必填及显示的名称为可以看懂的名称，如下示例： 1234567891011# 厂家class Manufacturers(models.Model): name = models.CharField(max_length=30, verbose_name=&apos;厂家名称&apos;) address = models.CharField(max_length=50, verbose_name=&apos;具体地址&apos;) city = models.CharField(max_length=60, verbose_name=&apos;所在地市&apos;) province = models.CharField(max_length=30, verbose_name=&apos;所在省份&apos;) website = models.URLField(blank=True, null=True, verbose_name=&apos;网址&apos;) # 表单允许为空 修改数据库结构，表示字段可为空 def __str__(self): return u&apos;%s&apos; % (self.name)... 注：上述示例中：blank=True表示表单输入可为空， null=True表示数据库存值是如果是空也存为空，而不是字符”NULL”,verbose_name=’网址’表示自定义名称 自定义ModelAdmin类具体使用及属性设置明细见如下示例（此处可以打开后台管理界面给大家演示一下）： 123456789101112131415161718192021222324252627from django.contrib import adminfrom .models import Manufacturers, Vender, Product# Register your models here.class ProductAdmin(admin.ModelAdmin): list_display = (&apos;title&apos;, &apos;product_date&apos;, &apos;manufacturers&apos;) # 注意 此处不能包含多对多字段 search_fields = (&apos;title&apos;, &apos;product_date&apos;) # 添加列表搜索框内容，注意只有一个框，但输入内容后悔搜索多个字段，类似于ES的机制 list_filter = (&apos;product_date&apos;,) # 右侧的过滤条 可以是日期 布尔 一对一外键类型 date_hierarchy = &apos;product_date&apos; # 显示日期导航，注意只能添加一个导航 ordering = (&apos;-product_date&apos;,) # 列表根据日期降序排序 fields = (&apos;product_date&apos;, &apos;title&apos;, &apos;manufacturers&apos;, &apos;vender&apos;) # 自定义编辑表单，修改卡片页面排序，还可以排除字段，排除的字段将不能编辑 raw_id_fields = (&apos;manufacturers&apos;,) # 针对一对一内容太多而做的界面优化，一般为下拉框内容太多的优化 filter_horizontal = (&apos;vender&apos;,) # 针对一对多内容太多而做的通过弹出框筛选class VenderAdmin(admin.ModelAdmin): list_display = (&apos;name&apos;, &apos;address&apos;) search_fields = (&apos;name&apos;, &apos;address&apos;)class ManufacturersAdmin(admin.ModelAdmin): list_display = (&apos;name&apos;, &apos;address&apos;) search_fields = (&apos;name&apos;, &apos;address&apos;) # 将自定义的ModelAdmin注册到后台管理admin.site.register(Manufacturers, ManufacturersAdmin)admin.site.register(Vender, VenderAdmin)admin.site.register(Product, ProductAdmin)","categories":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://jjw-story.github.io/tags/Django/"}],"author":"JJW"},{"title":"Django-02","slug":"Django-02","date":"2019-08-04T02:31:02.000Z","updated":"2019-08-11T05:40:34.779Z","comments":true,"path":"2019/08/04/Django-02/","link":"","permalink":"https://jjw-story.github.io/2019/08/04/Django-02/","excerpt":"","text":"Djongo表单从请求对象中获取数据 属性 方法说明 示例 request.path 完整的路径，不含域名，但是含前导斜线 “/hello/” request.get_host() 主机名（即通常所说的“域名”） “127.0.0.1:8000”或“www.example.com” request.get_full_path() 包含查询字符串（如果有的话）的路径 “/hello/?print=true” request.is_secure() 通过 HTTPS 访问时为True，否则为False True 或False request.META[‘HTTP_USER_AGENT’] 入站前的 URL（可能没有） request.META[‘HTTP_USER_AGENT’] 浏览器的用户代理（可能没有），请求头信息 “Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17” request.META[‘REMOTE_ADDR’] 客户端的 IP 地址 “12.345.67.89”。（如果请求经由代理，这个首部的值可能是一组 IP 地址，以逗号分隔） 简单的表单使用示例这里可以打开页面及项目代码为大家演示 视图函数如下： 123456789101112131415161718192021222324from django.shortcuts import renderfrom django.http import HttpResponsefrom cerealsOils.models import Product# Create your views here.def product_search(request): return render(request, &apos;product_search.html&apos;)def search(request): errors = [] if &apos;q&apos; in request.GET : # 通过request对象直接获取传统get请求的参数： q=xxx if ( request.GET[&apos;q&apos;]) : # 判断表单q参数是否为空 q = request.GET[&apos;q&apos;] if len(q) &gt; 5 : errors.append(&quot;查询关键字不能超过五个字符&quot;) else : products = Product.objects.filter(title__contains=q) # 过滤查询 # name = products[0].vender[0] return render(request, &apos;product_search.html&apos;, &#123;&apos;products&apos;: products, &apos;query&apos;: q&#125;) else : # products = Product.objects.all() # 查询所有 errors.append(&quot;查询关键字不能为空&quot;) return render(request, &apos;product_search.html&apos;, &#123;&apos;errors&apos;:errors&#125;) URL配置如下： 12url(r&apos;^product_search/$&apos;, views.product_search), # 查询页面跳转url(r&apos;^search/$&apos;, views.search), # 查询控制层 product_search模板如下： 1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;title&gt;产品查询&lt;/title&gt; &lt;meta charset=&apos;UTF-8&apos;&gt; &lt;/head&gt; &lt;body&gt; &#123;% if errors %&#125; &lt;ul&gt; &#123;% for error in errors %&#125; &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &lt;!-- &lt;form action=&quot;/search/&quot; method=&quot;get&quot;&gt; --&gt; &lt;form action=&quot;/search/&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Search&quot;&gt; &lt;/form&gt; &lt;p&gt;查询关键字: &lt;strong&gt;&#123;&#123; query &#125;&#125;&lt;/strong&gt;&lt;/p&gt; &#123;% if products %&#125; &lt;p&gt;产品总数 &#123;&#123; products|length &#125;&#125; 产品&#123;&#123; books|pluralize &#125;&#125;&lt;/p&gt; &lt;ul&gt; &#123;% for product in products %&#125; &lt;li&gt;产品名称：&#123;&#123; product.title &#125;&#125; 生产日期：&#123;&#123; product.product_date &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% else %&#125; &lt;p&gt;没有查询到商品&lt;/p&gt; &#123;% endif %&#125; &lt;/body&gt;&lt;/html&gt; 这样就完成了一个表单的使用示例 联系表单Django 自带了一个表单库，django.forms，它能处理从显示 HTML 表单到验证。 这个表单框架的主要用法是为要处理的每个 HTML 表单定义一个Form 类，这个类可以放在任意位置，例如直接放在views.py 文件中，不过社区的约定是，把Form 类放在单独的forms.py 文件中。 下面对表单框架的各部分功能以及自定义校验规则等进行示例： 在views.py 文件所在的目录（mysite）中创建这个文件，然后输入下述内容： 12345678910111213141516# 引入框架的表单库from django import formsclass ContactForm(forms.Form): subject = forms.CharField(max_length=20, min_length=2) # 校验长度 email = forms.EmailField(required=False) # 选项表示表单内容非必填 message = forms.CharField(widget=forms.Textarea) # 可以直接设置表单样式，注意表单样式设置也可以很灵活，使用时具体查看资料 # 自定义校验规则 # 注意校验方法名，需要以clean_开头，字段名称为结尾 # 再检查此规则前定义字段时设置的校验规则已经校验完毕 def clean_message(self): message = self.cleaned_data[&apos;message&apos;] if &quot;香港&quot; in message: raise forms.ValidationError(&quot;消息内容不能包含敏感词&quot;) return message # 一定要显式的返回清理后的值，cleaned_data是清理值 定义视图函数： 1234567891011121314151617def contact(request): if request.method == &apos;POST&apos;: form = ContactForm(request.POST) # Post请求体接受为form表单对象，这点类似于mvc if form.is_valid(): # 校验表单输入是否符合定义的校验规则 cd = form.cleaned_data send_mail( cd[&apos;subject&apos;], cd[&apos;message&apos;], cd.get(&apos;email&apos;, &apos;noreply@example.com&apos;), [&apos;siteowner@example.com&apos;], ) return HttpResponseRedirect(&apos;/contact/thanks/&apos;) else: form = ContactForm( initial=&#123;&apos;subject&apos;: &apos;默认值&apos;&#125; # 设置form表单默认值 ) return render(request, &apos;test/contact_form.html&apos;, &#123;&apos;form&apos;: form&#125;) 定义模板文件： 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;title&gt;联系表单&lt;/title&gt; &lt;meta charset=&apos;UTF-8&apos;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;表单测试&lt;/h1&gt; &#123;% if form.errors %&#125; &lt;!-- 接受表单对象数据 --&gt; &lt;p style=&quot;color: red;&quot;&gt; 请处理表单错误内容&#123;&#123; form.errors|pluralize &#125;&#125; &lt;/p&gt; &#123;% endif %&#125; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;field&quot;&gt; &#123;&#123; form.subject.errors &#125;&#125; &lt;label for=&quot;id_subject&quot;&gt;科目:&lt;/label&gt; &#123;&#123; form.subject &#125;&#125; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &#123;&#123; form.email.errors &#125;&#125; &lt;label for=&quot;id_email&quot;&gt;输入您的邮箱:&lt;/label&gt; &#123;&#123; form.email &#125;&#125; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &#123;&#123; form.message.errors &#125;&#125; &lt;label for=&quot;id_message&quot;&gt;消息内容:&lt;/label&gt; &#123;&#123; form.message &#125;&#125; &lt;/div&gt; &#123;% csrf_token %&#125; &lt;!-- 跨域处理 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 至此一个联系表单就创建完成了 高级视图和URL简化导入函数方式简化导入函数方式就是说我们直接导入views 模块自身，如下示例： 123456# 直接导入viewfrom cerealsOils import viewsurlpatterns = [ url(r&apos;^product_search/$&apos;, views.product_search), # 查询页面跳转 url(r&apos;^search/$&apos;, views.search), # 查询控制层 具名分组（Python具名函数的使用）正则表达式分组（通过括号实现）捕获 URL 中的片段， 123456urlpatterns = [ url(r&apos;^reviews/2003/$&apos;, views.special_case_2003), url(r&apos;^reviews/([0-9]&#123;4&#125;)/$&apos;, views.year_archive), url(r&apos;^reviews/([0-9]&#123;4&#125;)/([0-9]&#123;2&#125;)/$&apos;, views.month_archive), url(r&apos;^reviews/([0-9]&#123;4&#125;)/([0-9]&#123;2&#125;)/([0-9]+)/$&apos;, views.review_detail),] 如上捕获参数时，我们可以通过具名分组，为参数赋予名称： 123456urlpatterns = [ url(r&apos;^reviews/2003/$&apos;, views.special_case_2003), url(r&apos;^reviews/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&apos;, views.year_archive), url(r&apos;^reviews/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&apos;, views.month_archive), url(r&apos;^reviews/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;day&gt;[0-9]&#123;2&#125;)/$&apos;,views.review_detail),] 如上示例含义如下： 对/reviews/2005/03/ 的请求调用views.month_archive(request, year=’2005’, month=’03’) 函数，而不是views.month_archive(request,’2005’,’03’)。 对/reviews/2003/03/03/ 的请求调用views.review_detail(request, year=’2003’, month=’03’,day=’03’) 函数。 匹配/分组算法URL 配置解析器解析正则表达式中具名分组和非具名分组所采用的算法如下： 如果有具名分组，使用具名分组，忽略非具名分组。 否则，以位置参数传递所有非具名分组。 不论如何，额外的关键字参数都会传给视图。 URL及视图一些特性 注意url的匹配规则，它不区分请求的类型，例如GET POST等，只要url一样，都交给同一个视图函数处理。 不管正则表达式匹配的是什么类型，捕获的每个参数都以普通的 Python 字符串传给视图。 例如： 1url(r&apos;^reviews/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&apos;, views.year_archive) 虽然[0-9]{4} 只匹配字符串中的整数，但是传给views.year_archive() 视图函数的year 参数是字符串，而不是整数。 可以为视图函数的参数指定默认值(利用的也是Python函数的特性) 例如： 12345678urlpatterns = [ url(r&apos;^reviews/$&apos;, views.page), # 使用默认参数 url(r&apos;^reviews/page(?P&lt;num&gt;[0-9]+)/$&apos;, views.page), # 这里有传值，不使用默认参数]# 视图（在 reviews/views.py 文件中）def page(request, num=&quot;1&quot;):# 输出指定数量的书评 性能问题：urlpatterns 中的每个正则表达式在首次访问时编译，因此系统的速度异常得快。 引入其他URl配置urlpatterns 在任何位置都可以“引入”其他 URL 配置模块。通过这一行为可以把一些 URL 放在另一些名下。 例如： 123456urlpatterns = [ # ... url(r&apos;^community/&apos;, include(&apos;django_website.aggregator.urls&apos;)), url(r&apos;^contact/&apos;, include(&apos;django_website.contact.urls&apos;)), # ...] 注意，这里的正则表达式没有$（匹配字符串末尾的符号），但是末尾有斜线。Django 遇到include() 时，会把截至那一位置匹配的 URL 截断，把余下的字符串传给引入它的 URL 配置，做进一步处理。 可以利用这一点将公共的路径提取出来，示例如下： 1234567891011注意，url的配置可以抽取共性配置urlpatterns = [ url(r&apos;^chehejia/&apos;, include([ # 引入 ，引入可以引入其他URL配置模块，这里是写死的，还可以写成引入 xxx，其中xxx指的是 .py 文件，此文件中也有urlpatterns变量定义了url映射。 可以根据url的全路径匹配到引入模块的映射函数 url(r&apos;^add/$&apos;, views.add), url(r&apos;^edit/$&apos;, views.edit), url(r&apos;^delete/$&apos;, views.delete), url(r&apos;^save/$&apos;, views.save), ]) ),] 注意：通过此方式引入的URl配置，我们在父URl中使用正则捕获到的参数，是可以传递给子URl视图函数的，所以可以放心使用 传递额外参数URL 配置允许向视图函数传递额外的参数，这些参数放在一个 Python 字典中。django.conf.urls.url() 函数的第三个参数是可选的，如果指定，应该是一个字典，指定要传给视图函数的额外关键字参数及其值。 例如： 12345urlpatterns = [ url(r&apos;^reviews/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&apos;, views.year_archive, &#123;&apos;foo&apos;: &apos;bar&apos;&#125; # 具名分组及设置默认参数 ),] 同样include()也同样适用此特性： 1234567891011# main.pyfrom django.conf.urls import include, url urlpatterns = [ url(r&apos;^reviews/&apos;, include(&apos;inner&apos;), &#123;&apos;reviewid&apos;: 3&#125;),]# inner.pyurlpatterns = [ url(r&apos;^archive/$&apos;, views.archive), url(r&apos;^about/$&apos;, views.about),] 反向解析URl这个不太明白，我认为就是转发请求的时候使用，注意讨论一下 Django 提供了一种方案，只需在 URL 映射中设计 URL。我们为其提供 URL 配置，然后可以双向使用： 从用户（浏览器）请求的 URL 开始，这个方案能调用正确的 Django 视图，并从 URL 中提取可能需要的参数及其值，传给视图。 从 Django 视图对应的标识以及可能传入的参数值开始，获取相应的 URL。 第一点就是我们目前所讨论的处理方式。第二点称为反向解析 URL、反向匹配 URL、反向查找 URL 或 URL反转。 Django 在不同的层中提供了执行 URL 反转所需的工具： 在模板中，使用url 模板标签。 在 Python 代码中，使用django.core.urlresolvers.reverse() 函数。 在处理 Django 模型实例 URL 相关的高层代码中，使用get_absolute_url() 方法。 示例： 123456789101112131415161718192021# URl描述urlpatterns = [ url(r&apos;^reviews/([0-9]&#123;4&#125;)/$&apos;, views.year_archive, name=&apos;reviews-year-archive&apos;),]# 模板中如下描述&lt;ul&gt; &#123;% for yearvar in year_list %&#125; &lt;li&gt;&lt;a href=&quot;&#123;% url &apos;reviews-year-archive&apos; yearvar %&#125;&quot;&gt;&#123;&#123; yearvar &#125;&#125; Archive&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;# 视图函数如下from django.core.urlresolvers import reversefrom django.http import HttpResponseRedirectdef redirect_to_year(request): # ... year = 2012 # ... return HttpResponseRedirect(reverse(&apos;reviews-year-archive&apos;, args=(year,))) URl命名空间URL 命名空间在反转具名 URL 模式时具有唯一确定性，即便不同的应用使用相同的名称也不怕。 正确使用 URL 命名空间的 Django 应用程序可以在同一个网站中多次部署。例如，django.contrib.admin 中有个AdminSite 类，可以轻易部署多个管理后台。URL 命名空间分为两部分，而且都是字符串： 应用命名空间。指明应用的名称。一个应用的每个实例都具有相同的应用命名空间。例如，你可能猜到了，Django 管理后台的应用命名空间是admin。 实例命名空间。标识具体的应用程序实例。实例命名空间在整个项目范围内应该是唯一的。不过，实例命名空间可以与应用命名空间相同，供应用的默认实例使用。例如，Django 管理后台实例的默认实例命名空间是admin 命名空间中的 URL 使用: 运算符指定。例如，管理后台的主页使用 admin:index 引用。其中，admin 是命名空间，index 是 URL 的名称。 命名空间还可以嵌套。members:reviews:index 在命名空间members 中查找命名空间reviews，再在里面查找index URL。 反转命名空间的URl的步骤 首先，Django 查找有没有匹配的应用命名空间（这里的reviews）。为此，会产出那个应用的实例列表。 如果有这么一个应用实例，Django 返回它的 URL 解析程序。当前应用可以通过请求的一个属性指定。预期有多个部署实例的应用应该在处理的请求上设定current_app 属性。 当前应用也可以手动指定，方法是作为参数传给reverse() 函数。 如果没有当前应用，Django 查找默认的应用实例。默认应用实例是指实例命名空间与应用命名空间匹配的实例（在这里是指名为reviews 的reviews 实例）。 如果没有默认的应用实例，Django 选中最后部署的应用实例，而不管实例的名称。 如果第 1 步找不到匹配的应用命名空间，Django 直接把它视作实例命名空间查找。 URL 命名空间和引入的 URL 配置示例把引入的 URL 配置放入命名空间中有两种方式。 第一种，在 URL 模式中为include() 提供应用和实例命名空间： 1url(r&apos;^reviews/&apos;, include(&apos;reviews.urls&apos;, namespace=&apos;author-reviews&apos;, app_name=&apos;reviews&apos;)) 上述示例把reviews.urls 中定义的 URL 放在应用命名空间reviews 中，放在实例命名空间author-reviews中。 第二种，引入包含命名空间数据的对象。如果使用include() 引入一组url() 实例，那个对象中的 URL 都添加到全局命名空间中。然而，include() 的参数还可以是一个三元素元组： 123456reviews_patterns = [ url(r&apos;^$&apos;, views.IndexView.as_view(), name=&apos;index&apos;), url(r&apos;^(?P&lt;pk&gt;\\d+)/$&apos;, views.DetailView.as_view(), name=&apos;detail&apos;),]url(r&apos;^reviews/&apos;, include((reviews_patterns, &apos;reviews&apos;, &apos;author-reviews&apos;))), 上述示例把指定的 URL 模式引入指定的应用和实例命名空间中。 记得要把一个元组传给include()。如果直接传入三个参数，例如include(reviews_patterns, ‘reviews’,’author-reviews’)，Django 不会抛出错误，但是根据include() 的签名，’reviews’ 是实例命名空间，’author-reviews’ 是应用命名空间，而正确的顺序应该反过来。 高级模板技术RequestContext和上下文处理器模板要在上下文中渲染。上下文是django.template.Context 的实例，不过 Django 还提供了一个子类，django.template.RequestContext，其行为稍有不同。 RequestContext 默认为模板上下文添加很多变量，例如HttpRequest 对象或当前登录用户的信息，例如我们在视图函数中获取到的request对象，它就是Djongo为我们提供的上下文处理器，我们可以在此处理器中获取很多参数: 示例： 12345def view_1(request): # ... t = loader.get_template(&apos;template1.html&apos;) c = RequestContext(request, &#123;&apos;message&apos;: &apos;I am view 1.&apos;&#125;, processors=[custom_proc]) return t.render(c) 上下文处理器使用示例，提供公共的上下文处理器： 12345678910111213141516171819202122232425262728# 定义一个上下文处理器，提供 &apos;app&apos;、&apos;user&apos; 和 &apos;ip_address&apos;，可以在处理器中为多个请求提供共同的必要的上下文# 注意：上下文处理器必须返回一个字典# 自定义上下文处理器一般放在单独项目或者项目下的context_processors.py中def custom_proc(request): return &#123; &apos;app&apos;: &apos;我的上下文测试&apos;, &apos;user&apos;: request.user, &apos;ip_address&apos;: request.META[&apos;REMOTE_ADDR&apos;] &#125;# 引用上下文处理器直接返回给模板进行渲染# 注意processors函数的参数，第一个必须是request对象，第二个是可选的上下文处理器列表或元组def view_1(request): return render(request, &apos;template1.html&apos;, &#123;&apos;message&apos;: &apos;消息1&apos;&#125;, context_instance=RequestContext( request, processors=[custom_proc] ) )# 与上述一致，公用上下文处理器def view_2(request): return render(request, &apos;template2.html&apos;, &#123;&apos;message&apos;: &apos;消息2&apos;&#125;, context_instance=RequestContext( request, processors=[custom_proc] ) ) Djongo提供的上下文处理器在settings文件中，我们来逐一说明Djongo提供的上下文处理器 123456789101112131415161718192021222324252627282930313233343536&apos;OPTIONS&apos;: &#123; # 默认的处理器上下文 &apos;context_processors&apos;: [ # 启用这个处理器后，RequestContext 中将包含下面两个变量 # debug：True。可以在模板中测试是否在DEBUG 模式中。 # sql_queries：&#123;&apos;sql&apos;: …, &apos;time&apos;: …&#125; 字典构成的列表，表示处理请求的过程中执行的 SQL 查询及其用时。列表中的值按查询的执行顺序排列，在访问时惰性生成 &apos;django.template.context_processors.debug&apos;, # 启用这个处理器后，RequestContext 中将包含request 变量，它的值是当前的HttpRequest 对象 &apos;django.template.context_processors.request&apos;, # 启用此处理器后将包含： # user：auth.User 的实例，表示当前登录的用户（如未登录，是AnonymousUser 实例）。 # perms：django.contrib.auth.context_processors.PermWrapper 实例，表示当前登录用户拥有的权限。 &apos;django.contrib.auth.context_processors.auth&apos;, # 启用这个处理器后，RequestContext 中将包含下面两个变量： # messages：消息框架设定的消息列表（里面的值是字符串） # DEFAULT_MESSAGE_LEVELS：消息等级名称到数字值的映射 &apos;django.contrib.messages.context_processors.messages&apos;, # 非默认，启用后将包含： # LANGUAGES：LANGUAGES 设置的值 # LANGUAGE_CODE：如果request.LANGUAGE_CODE 存在，返回它的值；否则返回LANGUAGE_CODE 设置的值 # django.template.context_processors.i18n # 非默认，启用这个处理器后，RequestContext 中将包含MEDIA_URL 变量，提供MEDIA_URL 设置的值 # django.template.context_processors.media # 非默认，启用这个处理程序后，RequestContext 中将包含STATIC_URL 变量，提供STATIC_URL 设置的值 # jango.template.context_processors.static # 非默认，这个处理器添加一个令牌，供csrf_token 模板标签使用，用于防范跨站请求伪造，（暂时不清楚具体意思） # django.template.context_processors.csrf ],&#125;, 模板加载内部机制DIRS 选项告诉 Django 模板目录有哪些的方法是使用设置文件中TEMPLATES 设置的DIRS 选项，或者是Engine 的dirs 参数。这个选项的值是一个字符串列表，包含指向模板目录的完整路径： 123456789TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [ &apos;/home/html/templates/lawrence.com&apos;, &apos;/home/html/templates/default&apos;, ], &#125;,] 模板可以放在任何位置，只要 Web 服务器有权限读取目录及里面的模板即可。模板的扩展名不限，可以是.html 或.txt，甚至可以没有。注意，这里的路径应该使用 Unix 风格的正斜线，即便在 Windows 中也是如此。 加载器类型说明123456789101112# 加载器# 默认使用 ilesystem.Loader 文件系统加载器，如果不设定DIRS 选项，这个加载器找不到任何模板。# DIRS 定义一个目录列表，模板引擎按顺序在里面查找模板源文件。# 当前设置表示在项目根目录中放一些主模板，模板目录不一定非得叫&apos;templates&apos;，可以自定义&apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)],# 还有应用目录加载器 pp_directories.Loader# INSTALLED_APPS = [&apos;myproject.reviews&apos;, &apos;myproject.music&apos;]# 从文件系统中的 Django 应用里加载模板。这个加载器在INSTALLED_APPS 列出的各个应用中查找templates 子目录。如果找到，Django 在其中查找模板。# 这意味着，应用可以自带模板。通过这一行为，便于分发带默认模板的 Django 应用。例此加载器会在设置的文件夹中顺序的加载模板，最先找到的被加载，所以设置顺序很重要# 还有一些其他加载器，默认是禁用的，自行了解 Django模型的高级用法新增和修改对象save和create方法，如下： 12345678910111213141516m01 = Manufacturers(name=&apos;金龙鱼&apos;，address=&apos;铁岭&apos;, city=&apos;大连&apos;, province=&apos;沈阳&apos;, website=&apos;www.xmy.com&apos;)# save方法保存m01.save()# create方法保存m02 = Manufacturers.objects.create(name=&apos;金龙鱼&apos;，address=&apos;铁岭&apos;, city=&apos;大连&apos;, province=&apos;沈阳&apos;, website=&apos;www.xmy.com&apos;)# 当数据被保存后，及对象ID值是有的，直接再次调用save方法，就是修改对象，注意这里是全字段修改m02.name = &apos;鲁花&apos;m02.save()# 一个语句更新一个对象Manufacturers.objects.get(name=&apos;金龙鱼&apos;).save(city=&apos;黑龙江&apos;)# 一个语句中更新多条数据Manufacturers.objects.filter(name=&apos;金龙鱼&apos;).update(city=&apos;黑龙江&apos;) 查询数据all、filter、get方法等，如下： 1234567891011121314# 获取所有数据Manufacturers.objects.all()# 根据条件获取部分数据Manufacturers.objects.filter(name=&apos;金龙鱼&apos;)# 根据多个条件获取部分数据Manufacturers.objects.filter(name=&apos;金龙鱼&apos;, address=&apos;铁岭&apos;)# 类似SQL使用like语句过滤获取部分数据，字段加两个下划线，接containsManufacturers.objects.filter(name__contains=&apos;金&apos;)# 获取单个数据，此方法返回的就不是列表了，而是单条数据，如果查询出多条数据或者没有查询出数据，会抛出异常Manufacturers.objects.get(website=&apos;www.xmy.com&apos;) 排序数据order_by方法，具体如下： 12345678# 根据name排序，正向Manufacturers.objects.order_by(&apos;name&apos;)# 根据多个字段排序Manufacturers.objects.order_by(&apos;name&apos;, &apos;province&apos;)# 反向排序，方法是在字段名称前面加上“-”（减号）Manufacturers.objects.order_by(&apos;-name&apos;) 链式查找既过滤加排序，如下： 1Manufacturers.objects.filter(name=&apos;金龙鱼&apos;).order_by(&apos;-name&apos;) 切片数据及传统上理解的分页查找，如下： 12345# 返回查询出的第一条数据Manufacturers.objects.filter(name=&apos;金龙鱼&apos;)[0]# 分页查询，底层使用的是Mysql的Limit函数Manufacturers.objects.filter(name=&apos;金龙鱼&apos;)[0, 10] 删除数据delete方法，如下： 12345678# 删除一条数据Manufacturers.objects.get(name=&apos;金龙鱼&apos;).delete()# 删除多条数据Manufacturers.objects.filter(name=&apos;金龙鱼&apos;).delete()# 删除全部数据Manufacturers.objects.all().delete() 访问外键数据根据外键查询出关联的对象，如下： 123# 一对一关联manufacturers = Product.objects.get(title=&apos;小米&apos;).manufacturersmanufacturersName = Product.objects.get(title=&apos;小米&apos;).manufacturers.name 访问多对多数据多对多关联数据获取如下： 12345678910# 获取所有关联vender = Product.objects.get(title=&apos;小米&apos;).vender.all()# 过滤多对多数据vender = Product.objects.get(title=&apos;小米&apos;).vender.filter(name=&apos;供应商&apos;)# 反过来，查看经销商经销的所有产品，字段加 _setVender.objects.get(name=&apos;供应商&apos;).product_set.all()count = Product.vender.count() 管理器在Book.objects.all() 语句中，objects 是个特殊的属性，我们通过它查询数据库，这是模型的管理器（manager）。现在，我们要深入说明管理器的作用和用法。 添加额外的自定义管理器，修改模型如下： 123456789101112131415161718192021222324# 自定义模型管理器class MyProductManager(models.Manager): # 覆盖的get_queryset() 返回的是一个QuerySet 对象，它对应着我们管理器的all()方法 def get_queryset(self): return super(MyProductManager, self).get_queryset().filter(name=&apos;大米&apos;)# 产品class Product(models.Model): title = models.CharField(max_length=100, verbose_name=&apos;产品名称&apos;) vender = models.ManyToManyField(Vender, verbose_name=&apos;经销商&apos;) manufacturers = models.ForeignKey(Manufacturers, verbose_name=&apos;厂家&apos;) product_date = models.DateField(verbose_name=&apos;生产日期&apos;) # fields = (&apos;title&apos;, &apos;product_date&apos;, &apos;vender&apos;, &apos;manufacturers&apos;) # 我们明确地把objects 设为一个普通的Manager 示例，如若不然，唯一可用的管理器将是dahl_objects objects = models.Manager() # 默认的管理器 my_objects = MyProductManager() # 专门查询 产品名称为大米 的管理器 def __str__(self): return u&apos;%s %s&apos; % (self.title, self.product_date) # 任何模型都可以使用Meta 类指定多个针对所在模型的选项。 class Meta: ordering = [&apos;product_date&apos;] 下面是使用上述自定义管理器示例： 1234# get_queryset() 返回的是一个QuerySet 对象，因此可以在其上调用filter()、exclude() 和其他所有QuerySet 支持的方法Product.my_objects.all()Product.my_objects.filter(title=&apos;Matilda&apos;)Product.my_objects.count() 如果需要，我们可以在同一个模型上使用多个管理器。 模型方法模型方法就是为Model提供一些方法，我们调用这些方法的时候能处理一些我们想要的逻辑。 模型为我们自动提供的常用方法有如下： str()。这是 Python 的一个“魔法方法”，返回对象的 Unicode 表示形式。需要以普通的字符串显示模型实例时，Python 和 Django 会调用这个方法。尤其要注意，在交互式控制台或管理后台中显示对象调用的都是这个方法。这个方法一定要自定义，因为默认的实现没什么用。 get_absolute_url()。这个方法告诉 Django 如何计算一个对象的 URL。Django 在管理后台和需要生成对象的 URL 时调用这个方法。具有唯一标识的 URL 的对象都要定义这个方法。 模型方法大多可以被直接覆盖，最常见的就是覆盖str()方法 一下演示覆盖预定义的模型方法，是针对数据库执行行为来覆盖的，例如： 1234567891011# 定义Blog模型，覆盖它的save方法，如下定义某些情况下不允许保存class Blog(models.Model): name = models.CharField(max_length=100) tagline = models.TextField() def save(self, *args, **kwargs): if self.name == &quot;Yoko Ono&apos;s blog&quot;: return # Yoko 肯定不会开博客的！ else: super(Blog, self).save(*args, **kwargs) # 调用“真正的”save () 方法 执行原始SQL模型的查询 API 不够用时，可以编写原始 SQL。Django 为执行原始 SQL 查询提供了两种方式：使用Manager.raw() 执行，返回模型实例集合；或者完全不用模型层，直接执行自定义SQL 第一种方式执行示例： 123456789101112131415161718# 基本查询分页Product.objects.raw(&apos;SELECT * FROM CEREALSOILS_PRODUCT LIMIT 0, 5&apos;)# 当我们定义的模型字段名称与数据库字段名称不一致时，可以通过AS将字段对应起来Product.objects.raw(&apos;SELECT product_name as name FROM CEREALSOILS_PRODUCT&apos;)# 延期模型字段# 注意：指定查询字段的时候，必须要包含主键字段p = Product.objects.raw(&apos;SELECT id, title FROM CEREALSOILS_PRODUCT&apos;)title = p.title # 上述执行取出的数product_date = p.product_date # 又执行了一次SQL来取出的此字段的值# 为raw传递参数，注意，这里是防注入的用法，参数写在raw方法内才有防注入的作用# 注意：Djongo中的占位符是 %s ，而不是 ?# 查询中有 % ，则需要写两个 %title = &apos;大米&apos;pa = Product.objects.raw(&apos;SELECT * FROM CEREALSOILS_PRODUCT where title = %s&apos;, title)p9 = Product.objects.raw(&apos;SELECT * FROM cerealsOils_product where title like %s LIMIT 0, 5&apos;, [&apos;%米%&apos;]) 第二种方式执行示例： django.db.connection 对象表示默认的数据库连接。若想使用这个数据库连接，调用connection.cursor()，然后，调用cursor.execute(sql, [params]) 执行 SQL，再调用cursor.fetchone() 或cursor.fetchall() 返回所得的行。 12345678910111213141516171819202122232425262728293031323334353637from django.db import connectiondef my_custom_sql(self): cursor = connection.cursor() cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz]) cursor.execute(&quot;SELECT foo FROM bar WHERE baz = %s&quot;, [self.baz]) row = cursor.fetchone() return row# 当需要连接多个数据库时，可以获取指定的数据库连接cursor = connections[&apos;my_db_alias&apos;].cursor()# 连接和游标（类似于Java中 Try-with-resouce）with connection.cursor() as c: c.execute(...)等效于：c = connection.cursor()try: c.execute(...)finally: c.close()# 查询数据，只返回结果没有字段名称映射cursor = connection.cursor()cursor.execute(&quot;SELECT id, title FROM cerealsOils_product&quot;)row01 = cursor.fetchone()row02 = cursor.fetchone()print(row01)print(row02)# 查询数据，有字段名称映射cursor01 = connection.cursor()cursor01.execute(&quot;SELECT id, title FROM cerealsOils_product&quot;)desc = cursor01.descriptiondict(zip([col[0] for col in desc], row))for row in cursor01.fetchall(): print(row)","categories":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://jjw-story.github.io/tags/Django/"}],"author":"JJW"},{"title":"文件及目录权限","slug":"文件及目录权限","date":"2019-08-03T12:20:20.000Z","updated":"2019-08-03T06:13:49.717Z","comments":true,"path":"2019/08/03/文件及目录权限/","link":"","permalink":"https://jjw-story.github.io/2019/08/03/文件及目录权限/","excerpt":"","text":"文件及目录权限的表示方法当我们使用 ls -l 命令查看详细文件内容时，可以看到查询出的内容如下： 123456789root@CHJ-20190520VPS:/usr/lib# ls -ltotal 920drwxr-xr-x 1 root root 4096 May 21 22:39 kerneldrwxr-xr-x 1 root root 4096 May 21 22:39 klibcdrwxr-xr-x 1 root root 4096 May 21 22:40 language-selectorlrwxrwxrwx 1 root root 21 Feb 12 16:55 libDeployPkg.so.0 -&gt; libDeployPkg.so.0.0.0-rw-r--r-- 1 root root 31280 Feb 12 16:55 libDeployPkg.so.0.0.0lrwxrwxrwx 1 root root 20 Feb 12 16:55 libguestlib.so.0 -&gt; libguestlib.so.0.0.0-rw-r--r-- 1 root root 22656 Feb 12 16:55 libguestlib.so.0.0.0 一共查询出七列内容，分别表示： 文件属性(占10个字符空间)、拥有的文件数量、文件的创建者、所属的group、文件大小、建档日期、文件名 文件属性Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x） 但是这里有十个格子可以填（具体程序实现时，实际上是十个bit位） 文件类型第一个小格是特殊表示格，表示目录或连结文件等等 d 表示目录，这个是在创建下来文件的类型就固定了下来，不可以人为进行更改 l 表示链接文件，类似于快捷方式 - 表示这是普通文件 b 块特殊文件，其实是指的是设备，比如我们插入一个移动硬盘，插入一个硬盘之后，Linux系统就会把他当成一个特出文件块文件来表示 c 字符特殊文件，就是终端 f 命名管道 s 套接字文件 文件权限表示方法字符权限表示方法： r 读 w 写 x 执行 数字权限的表示方法（8进制数字表示）： r=4 w=2 x=1 其余剩下的格子就以每3格为一个单位，因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。 另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 文件权限的修改修改权限命令chown命令修改属主或数组命令，使用方法： 修改属主：chown 用户名称 文件名称 修改属组：chown :用户组名称 文件名称 修改文件、目录权限。Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用 首先我们新创建一个目录，查看root用户新创建目录的默认权限，如下： 12root@CHJ-20190520VPS:/tmp# ls -ld testdir/drwxr-xr-x 1 root root 4096 Jul 27 15:05 testdir/ 表示文件的属主是root用户，root用户可以读写删除等，所属用户组不能删除，其他其他用户不能删除 这里我们需要了解，Linux权限限制是非root用户的，这里既是我们将文件或目录的权限给root修改了，但是root用户还是不受限制的 所以为了方便测试我们不要用root用户来操作，命令使用示例如下： 123456789101112131415# 修改属主root@CHJ-20190520VPS:/tmp# chown wangjia3 testdirroot@CHJ-20190520VPS:/tmp# ls -ld testdirdrwxr-xr-x 1 wangjia3 root 4096 Jul 27 15:05 testdir# 修改属组root@CHJ-20190520VPS:/tmp# groupadd group01root@CHJ-20190520VPS:/tmp# chown :group01 testdirroot@CHJ-20190520VPS:/tmp# ls -ld testdirdrwxr-xr-x 1 wangjia3 group01 4096 Jul 27 15:05 testdir# 属主属组一起修改root@CHJ-20190520VPS:/tmp# chown wangjia3:group01 testdir/root@CHJ-20190520VPS:/tmp# ls -ld testdir/drwxr-xr-x 1 wangjia3 group01 4096 Aug 3 12:35 testdir/ 可以看到文件的属主和属组已经改变 chgrp命令修改属组命令，使用方法：chgrp 用户组名称 文件名称 使用示例： 123root@CHJ-20190520VPS:/tmp# chgrp root testdirroot@CHJ-20190520VPS:/tmp# ls -ld testdirdrwxr-xr-x 1 wangjia3 root 4096 Jul 27 15:05 testdir 可以看到文件的属组已经被修改回为root分组 创建文件的默认权限我们创建一个新的文件，默认的权限如下所示： 123root@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rw-r--r-- 1 root root 0 Aug 3 12:35 demoFile 那它是怎么来的呢？其实创建新的文件默认的权限是数字表示法：666，表示属主属组其他都是拥有读写权限，但它会根据数字权限表示减去一个uumask，umask表示如下： 12root@CHJ-20190520VPS:/tmp/testdir# umask0022 所以这就是我们创建文件的默认权限的由来，是使用 666 减去 umask 得到的默认权限 chmod命令chmod是Linux/Unix中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性 使用方法：chmod [修改内容 修改符号 权限] 文件 修改字符权限参数详解修改内容 u 修改文件属主的权限 g 修改文件属组的权限 r 修改其他以外的权限 a 以上三者都修改 具体权限修改 + 增加权限 - 取消权限 = 直接设定权限 此三条具体设置的权限就是我们之前了解的：r、w、x 使用示例： 123456789101112131415161718192021222324252627root@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rw-r--r-- 1 root root 0 Aug 3 12:35 demoFile# 属主增加执行权限root@CHJ-20190520VPS:/tmp/testdir# chmod u+x demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwxr--r-- 1 root root 0 Aug 3 12:35 demoFile# 属组取消读权限root@CHJ-20190520VPS:/tmp/testdir# chmod o-r demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwxr----- 1 root root 0 Aug 3 12:35 demoFile# 其他设置执行和读权限root@CHJ-20190520VPS:/tmp/testdir# chmod o=xr demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwxr--r-x 1 root root 0 Aug 3 12:35 demoFile# 所有设置读写执行权限root@CHJ-20190520VPS:/tmp/testdir# chmod a=xwr demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwxrwxrwx 1 root root 0 Aug 3 12:35 demoFile 修改数字权限修改方法：chmod [数字] 文件 注意：以上参数中数字为3位数 参数详解三位数字第一位代表属主权限，第二位代表属组权限，第三位代表其他权限 数字则分别用 1、2、4 来分别表示 执行、写、读 使用示例： 123456789101112131415root@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwxrwxrwx 1 root root 0 Aug 3 12:35 demoFile# 设置取消所有权限root@CHJ-20190520VPS:/tmp/testdir# chmod 000 demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0---------- 1 root root 0 Aug 3 12:35 demoFile# 设置属主读写权限，属组和其他读权限root@CHJ-20190520VPS:/tmp/testdir# chmod 644 demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rw-r--r-- 1 root root 0 Aug 3 12:35 demoFile 特殊权限SUID用于二进制可执行文件，执行命令时取得文件的属主权限，例如 /usr/bin/password 12wangjia3@CHJ-20190520VPS:/tmp/testdir$ ls -l /usr/bin/passwd-rwsr-xr-x 1 root root 59640 Mar 23 03:05 /usr/bin/passwd 如上示例中：属主权限是 ws，s 之前是我们没有解释过的，它表示的是不管是root用户还是普通用户，它在执行这条命令时，它都会以文件的属主的这种身份来进行操作 它的作用就是，我们有些文件用户是没有任何权限的，例如保存用户账户密码的文件，/etc/shadow: 12wangjia3@CHJ-20190520VPS:/tmp/testdir$ ls -l /etc/shadow-rw-r----- 1 root shadow 1153 Jul 27 13:38 /etc/shadow 我们当前登录的用户是没有此文件的任何权限的，而root用户有此文件的权限，那我们普通用户为什么能修改密码呢，就是我们在修改密码例如passwd文件的时候，它能以root用户的身份来执行，这样就避免了我们需要主动去切换用户的修改密码的问题。 SGID用于目录，在该目录下创建新的文件和目录，权限自动更改为该目录的数组，一般是我们在文件共享的时候，一般会用到SET GID SBIT用于目录，该目录下新建的文件和目录，仅root和自己可以删除，如/tmp 12wangjia3@CHJ-20190520VPS:/$ ls -ld /tmpdrwxrwxrwt 1 root root 4096 Aug 3 13:50 /tmp 注意在其他位有一个t，这样就可以防止自己创建的文件被其他的普通用户修改或删除 设置特殊权限使用的也是 chmod命令，用法与上述修改权限用法一致，只不过多了由三位数变为了四位数，第一位为特殊权限的表示数字 特殊权限数字表示： 4 SET UID 123456789root@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0----rw---- 1 wangjia3 wangjia3 0 Aug 3 12:35 demoFileroot@CHJ-20190520VPS:/tmp/testdir# chmod 4644 demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rwSr--r-- 1 wangjia3 wangjia3 0 Aug 3 12:35 demoFile 1 SET BIT 1234root@CHJ-20190520VPS:/tmp/testdir# chmod 1644 demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rw-r--r-T 1 wangjia3 wangjia3 0 Aug 3 12:35 demoFile 2 SET GID 1234root@CHJ-20190520VPS:/tmp/testdir# chmod 2644 demoFileroot@CHJ-20190520VPS:/tmp/testdir# ls -ltotal 0-rw-r-Sr-- 1 wangjia3 wangjia3 0 Aug 3 12:35 demoFile 注意特殊权限一般不要去自己随便指定，使用系统默认就行","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件及目录权限","slug":"文件及目录权限","permalink":"https://jjw-story.github.io/tags/文件及目录权限/"}],"author":"JJW"},{"title":"su-sudo命令","slug":"su-sudo命令","date":"2019-07-27T01:07:11.000Z","updated":"2019-07-27T04:15:12.298Z","comments":true,"path":"2019/07/27/su-sudo命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/27/su-sudo命令/","excerpt":"","text":"su命令Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码 使用方法：su [选项] [用户名称] 选项说明 -f 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh -c 既command，变更为帐号为指定账号的使用者并执行指定指令（command）后再变回原来使用者，使用方法：su -c [指定命令] 用户名称 -m -p 既preserve、environment，执行 su 时不改变环变量 - -l login这个参数加了之后，就好像是重新login为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该指定用户为主，并且工作目录也会改变，如果没有指定用户，内定是 root -s 指定要执行的shell （bash csh tcsh 等），预设值为 /etc/passwd 内的指定用户shell 使用示例： 1234567891011121314wangjia3@CHJ-20190520VPS:~$ pwd/home/wangjia3wangjia3@CHJ-20190520VPS:~$ su rootPassword:root@CHJ-20190520VPS:/home/wangjia3# pwd/home/wangjia3root@CHJ-20190520VPS:~# su - wangjia3wangjia3@CHJ-20190520VPS:~$ pwd/home/wangjia3wangjia3@CHJ-20190520VPS:~$ su - rootPassword:root@CHJ-20190520VPS:~# pwd/root 注意 su 与 su - 的区别 sudo命令sudo 表示 “superuser do”。 它允许已验证的用户以其他用户的身份来运行命令。其他用户可以是普通用户或者超级用户。然而，大部分时候我们用它来以提升的权限来运行命令 以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行 使用方法：su [参数] 参数说明 -V 显示版本编号 -h 显示版本编号及指令的使用方式说明你 -l 显示出当前用户的权限 -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码 -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟） -b 将要执行的指令放在背景执行 -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell -i Linux终端命令下改变用户对命令使用权限的命令，加载用户变量，并跳转到目标用户home目录 经常使用参数示例： 1234567wangjia3@CHJ-20190520VPS:/$ sudo -l[sudo] password for wangjia3:Matching Defaults entries for wangjia3 on CHJ-20190520VPS: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser wangjia3 may run the following commands on CHJ-20190520VPS: (ALL : ALL) ALL 12345678wangjia3@CHJ-20190520VPS:~$ pwd/home/wangjia3wangjia3@CHJ-20190520VPS:~$ sudo -sroot@CHJ-20190520VPS:~# pwd/home/wangjia3root@CHJ-20190520VPS:~# sudo -iroot@CHJ-20190520VPS:~# pwd/root 注意 -s 和 -i 的区别 sudo命令使用补充通常我们使用普通用户使用一些命令是没有权限的，在使用这些没有权限的命令时需要切换到root用户，这样就需要告知普通用户root用户的密码，这样做是不安全的 例如我们执行shutdown命令时： 12[frog@iZm5ehzqow4ijp2ya2g2drZ ~]$ shutdown -h 60shutdown: Need to be root 显示需要使用root用户来操作此命令 这时我们可以使用visudo来修改sudo的配置文件，将此命令的使用权限赋给普通用户，来让普通用户有权限使用此命令，就可以不将root用户的密码告知与普通用户，安全的使用系统 visudo的使用时以vi开头的，其实就类似于使用 vi 打开了一个文件，使用操作与 vi 一致 1234567891011121314151617181920212223242526272829303132[root@iZm5ehzqow4ijp2ya2g2drZ /]# visudo## Sudoers allows particular users to run various commands as## the root user, without needing the root password.#### Examples are provided at the bottom of the file for collections...## user MACHINE=COMMANDS#### The COMMANDS section may have other options added to it.#### Allow root to run any commands anywhereroot ALL=(ALL) ALL## Allows members of the &apos;sys&apos; group to run networking, software,## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## Allows people in group wheel to run all commands# %wheel ALL=(ALL) ALL## Same thing without a password# %wheel ALL=(ALL) NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root# %users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom## Allows members of the users group to shutdown this system# %users localhost=/sbin/shutdown -h now## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment) 注意此文件最下方有几段关于使用sudo的设置说明，下面是设置说明： 12345## Allows people in group wheel to run all commands# %wheel ALL=(ALL) ALL## Same thing without a password# %wheel ALL=(ALL) NOPASSWD: ALL %wheel 表示的是如果我们要设置的是用户组，则需要用 % 加上用户组名称，如果只是单个用户，就直接写用户名即可 ALL=(ALL) 表示在哪台主机上可以执行哪些命令，哪来主机指的是我们登陆的主机，Linux可以在本地登陆，也可以远程登陆，如果在本地登陆那么主机就是localhost，locachost是字符端登陆，如果是字符或远程都去登陆，就赋予 ALL 的权限。 如果只赋予一些命令，如上述中：# %users localhost=/sbin/shutdown -h now，意思是赋予了用户shutdown -h now 的命令的使用权限 如果有多条命令，就将命令用 “,” 隔开，例如上述段落中示例：%users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom，表示赋予了用户mount、unmount命令 NOPASSWD: ALL 表示普通用户在使用管理员账户赋予它的这些命令时是否需要输入密码，这里 NOPASSWD: ALL 表示不需要输入密码，但是这种是不安全的，所以我们不建议此种设置类型 使用示例我们现在配置普通用户 frog 被赋予使用 shutdown -h 60 的权限，使用visudo来设置，修改如下： 123## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment)#includedir /etc/sudoers.dforg ALL=/sbin/shutdown -h 60 修改完成然后切换到frog用户执行此命令： 12345678910[root@iZm5ehzqow4ijp2ya2g2drZ /]# su -l frog[frog@iZm5ehzqow4ijp2ya2g2drZ ~]$ shutdown -h 60shutdown: Need to be root[frog@iZm5ehzqow4ijp2ya2g2drZ ~]$ sudo /sbin/shutdown -h 60[sudo] password for frog:Broadcast message from root@iZm5ehzqow4ijp2ya2g2drZ (/dev/pts/1) at 12:14 ...The system is going down for halt in 60 minutes! 注意：直接执行还是会告诉你没有权限，我们需要使用sudo命令来执行root赋予权限的命令，需要使用命令的全路径，然后提示输入密码之后就执行成功啦","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"su-sudo","slug":"su-sudo","permalink":"https://jjw-story.github.io/tags/su-sudo/"}],"author":"JJW"},{"title":"用户和权限管理","slug":"用户和用户组管理","date":"2019-07-25T12:00:00.000Z","updated":"2019-07-27T06:08:31.650Z","comments":true,"path":"2019/07/25/用户和用户组管理/","link":"","permalink":"https://jjw-story.github.io/2019/07/25/用户和用户组管理/","excerpt":"","text":"用户管理Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个惟一的用户名和各自的口令，用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改 用户口令的管理 用户组的管理 用户管理常用命令当前使用的Linux系统中已经有了两个用户，一个是root用户，一个是自己创建的用户，root用户是超级管理员，我们自己创建的用户是普通用户。LInux多用户其实就是将用户分成了两类用户，一类是root用户，一类是普通用户 root用户的权限比较大，它可以访问自己的家目录，访问系统的配置文件，例如之前我们修改的vim的配置文件，还有就是root用户还可以访问普通用户的家目录，但是普通用户的权限就受到了下去限制，它只能访问自己的家目录，以及root用户开放给它的一些没有危害到系统安全的目录文件 普通用户和普通用户之间是没有权限互相访问他们对方的家目录的，Linux就是通过这两种用户的区别，来做了最基本的权限隔离 用户添加命令用户添加命令实际使用的是 useradd命令，使用方法：useradd [选项] 用户名称 在添加用户完成后，我们可以使用 id 命令来验证是否添加成功，通过 id 命令，我们可以查看系统中有哪些已经存在的用户 1234567root@CHJ-20190520VPS:/# useradd wangjiasroot@CHJ-20190520VPS:/# id rootuid=0(root) gid=0(root) groups=0(root)root@CHJ-20190520VPS:/# id wangjiasuid=1001(wangjias) gid=1001(wangjias) groups=1001(wangjias)root@CHJ-20190520VPS:/# id abcid: ‘abc’: no such user 下面分析我们添加用户的时候Linux都做了哪些操作： 首先第一是为新添加的用户创建了它的家目录，创建完成我们访问的时候发现家目录是空的，但其实用户的家目录是存放了很多与用户相关的隐藏配置文件 第二步就是将我们创建的用户记录在 /etc/passwd 文件中，只要包含了如下所示内容，就说明我们系统中存在这样的一个用户 123root@CHJ-20190520VPS:/# cat /etc/passwd...wangjias:x:1001:1001::/home/wangjias:/bin/sh 第三步还会在 etc/shadow 文件中添加我们创建的用户信息，这个文件是用户密码相关的文件 还有就是我们每创建一个用户，都会创建一个独立的用户id，叫uid，如上述我们通过id命令查询出来的内容。注意root用户的id是0，如果我们把普通用户的id也修改为0，那么系统就会把此用户也当成root用户 第四就是还会为用户创建用户所属的组，如果我们没有明确指定所属的组，系统就会创建一个与用户同名的组作为新创建用户所属的组。如果我们希望有一组用户他们使用同样的资源的时候，就可以建立一个这样的用户组，然后把他们都加入到这个组里面，如果我们对这个组进行修改，就相当于对一组的用户全都进行修改 注意创建用户只有root用户有这样的权限，普通用户没有创建用户的权限 上面的创建我们没有指定选项，下面介绍一些选项： -c comment 指定一段注释性描述 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g 用户组 指定用户所属的用户组 -G 用户组，用户组 指定用户所属的附加组 -s Shell文件 指定用户的登录Shell -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 为用户设置密码用户登录是需要登录密码的，为用户设置密码的命令使用的是 passwd命令，使用方法：passwd [用户名] 注意用户名选项是可选的，如果不指定要修改密码的用户名，那就是修改当前用户的密码 1234root@CHJ-20190520VPS:/# passwd wangjiasEnter new UNIX password:Retype new UNIX password:passwd: password updated successfully 删除用户删除用户使用的是userdel命令，使用方法： userdel [选项] 用户名 注意我们一般删除用户的时候会添加上 “-r” 选项，如果我们直接使用用户删除命令删除用户，则此用户的家目录会被保留下来，当我们确认用户的家目录中的数据都可以被直接删除的时候，就可以添加 -r 这个选项，直接删除彻底。 如果执行的是彻底删除的命令，那么 /etc/passed 和 /etc/shadow 中的用户信息也会被删除 修改账号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，使用方法：usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值 经常使用的选项是 -d 选项，既指定用户新的家目录，使用方法：usermod -d 新的家目录 用户名 如果我们修改了用户的家目录，那么我们重新登录此用户的时候，它的默认目录就会成为我们修改的目录，并且关于此用户的配置文件也会放在新的家目录中 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新 用户组管理命令新建用户组新建用户组使用groupadd命令，使用方法：groupadd [选项] 用户组 选项一般使用 -g 选项，此选项用于指定用户组的组标识号 新建好组之后，有两种方式将用户添加至先建好的组，第一种是使用 usermod 命令： 12345root@CHJ-20190520VPS:/# groupadd -g 1001 group1root@CHJ-20190520VPS:/# useradd user1root@CHJ-20190520VPS:/# usermod -g group1 user1root@CHJ-20190520VPS:/# id user1uid=1001(user1) gid=1001(group1) groups=1001(group1) 可以看到我们已经将user1用户添加到了group1组中 第二种就是在新建用户的时候直接将用户添加至指定用户组中: 123root@CHJ-20190520VPS:/# useradd -g group1 user2root@CHJ-20190520VPS:/# id user2uid=1002(user2) gid=1001(group1) groups=1001(group1 修改用户组修改用户组的属性使用groupmod命令，使用方法：groupmod [选项] 用户组 常用选项如下： -g GID 为用户组指定新的组标识号 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同 -n 新用户组 将用户组的名字改为新名字 使用示例： 123root@CHJ-20190520VPS:/# groupmod -n group2 group1root@CHJ-20190520VPS:/# id user2uid=1002(user2) gid=1001(group2) groups=1001(group2) 删除用户组如果要删除一个已有的用户组，使用groupdel命令，使用方法：groupdel 用户组 1root@CHJ-20190520VPS:/# groupdel group2 用户和用户组配置文件用户和用户组相关的配置文件主要有三个，/etc/passwd、/ect/shadow、/etc/group passwd文件内容如下： 12345671 root:x:0:0:root:/root:/bin/bash2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin3 bin:x:2:2:bin:/bin:/usr/sbin/nologin4 sys:x:3:3:sys:/dev:/usr/sbin/nologin...30 wangjia3:x:1000:1000:,,,:/home/wangjia3:/bin/bash31 user01:x:1001:1001::/home/user01:/bin/sh 我们发现此文件被分成了七个字段，下面分别解释每个字段的含义： 用户名称字段，表示用户的名称，可以看到此文件最后的两行是我们之前新创建的用户 第二个字段表示此用户登录需要不需要密码验证，如果把这个 “x” 删除之后，我们发现登录用户将不需要验证 1234wangjia3@CHJ-20190520VPS:~$ su -l wangjia3Password:wangjia3@CHJ-20190520VPS:~$ su -l user01user01@CHJ-20190520VPS:/$ 第三个字段是用户的uid字段，Linux并不是通过用户的名称来识别用户的，它是通过用户的id来识别用户，如果id重复了就会用最小id的用户使用 第四个字段是gid，是当前用户属于哪一个组的标识字段 第五个字段是注释 第六个字段表示用户的家目录的位置 用户登录后使用的命令解释器，现在所通用的命令解释器都是bash命令解释器。我们发现有很多第七个字段显示的是 /usr/sbin/nologin， 这里表示的是此用户是不能登录终端的，例如我们将user01用户的此字段修改为nologin： 123456 30 wangjia3:x:1000:1000:,,,:/home/wangjia3:/bin/bash 31 user01:x:1001:1001::/home/user01:/usr/sbin/nologinroot@CHJ-20190520VPS:~# su -l user01This account is currently not available.root@CHJ-20190520VPS:~# 切换用户失败，提示此账户不能登录 我们可以直接在这里添加一行数据，来添加用户 shadowshadow文件是保存用户和用户密码相关信息的，我们需要了解它的前两个字段 1234528 sshd:*:18037:0:99999:7:::29 pollinate:*:18037:0:99999:7:::30 wangjia3:$6$486gKZ88$cobO1oh/kuz4HwAmnpnb.OQtszzD78m0e.KvbbxcEbNfIA9/4cSKvU78iTMOgFL8FstKrk0hIQ/S16P/R5o6t.:18080:0: 99999:7:::31 user01:$6$Pe7lIEqi$28CGKQAIa3E4JvTvAZKeymjFgVY5HvGZXVg0RuUWetl2YTlgU5sLcMzRs6FZmJbnIvad3IeJO4bPXs082KqL10:18104:0:99 999:7::: 第一个字段是用户名称字段，用来和passwd字段来进行对应 是用户加密过的密码，加密的密码是以$开头，然后一串字符，这样主要是为了保护用户的密码，及时用户的密码是相同的，但是在此文件中的显示也是不同的，防止被破解 group和用户组相关的配置文件，里面包含四个字段： 第一个字段是组的名称 第二个字段这个组是否需要密码验证 第三个字段表示这个组的gid 第四个字段，表示其他组字段，表示哪些用户属于其他组，这个其他组里面又包含了用户名称","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"用户和权限管理","slug":"用户和权限管理","permalink":"https://jjw-story.github.io/tags/用户和权限管理/"}],"author":"JJW"},{"title":"Python","slug":"Python","date":"2019-07-20T12:00:00.000Z","updated":"2019-07-24T09:40:11.920Z","comments":true,"path":"2019/07/20/Python/","link":"","permalink":"https://jjw-story.github.io/2019/07/20/Python/","excerpt":"","text":"Python基础Python语法注释注释的三种方式如下： 123456789# 注释&apos;&apos;&apos;注释&apos;&apos;&apos;&quot;&quot;&quot;这也是注释&quot;&quot;&quot; 缩进python不需要 {} 都是使用缩进表示代码块 字符串字符串可以 ‘ ‘， “ “, “”” “”” 123456&apos;字符串&apos;&quot;字符串&quot;&quot;&quot;&quot;多行字符串&quot;&quot;&quot; 空行函数之间或类方法之间用空行分开 ; 符号同一行可以显示多条语句，使用 ; 隔开 导入 在 python 用 import 或者 from…import 来导入相应的模块 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * end关键字关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符 123while b &lt; 1000: print(b, end=&apos;,&apos;) b += 1 条件控制123456789101112if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句elif 表达式4: 语句else: 语句 循环while循环: 123456count = 0while count &lt; 5:print (count, &quot; 小于 5&quot;)count = count + 1else:print (count, &quot; 大于或等于 5&quot;) for循环： 12345678sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]for site in sites: if site == &quot;Runoob&quot;: print(&quot;菜鸟教程!&quot;) break print(&quot;循环数据 &quot; + site)else: print(&quot;没有循环数据!&quot;) 注意：以上循环中，else为跳出循环后执行的逻辑，且只执行一次，可以不存在else range()函数： 12345for i in range(103) : print(i)for i in range(0, 10, 3) : print(i) 参数最多可以有三个，第一个为开始限定，第二个为结束限定，第三个为步长 123a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]for i in range(len(a)): print(i, a[i]) break、continue break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环 pass 语句： 12while True: pass 遍历技巧： 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到： 1234567for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]): print(i, v)# 结果0 tic1 tac2 toe 反向遍历： 12for i in reversed(range(1, 10, 2)): print(i) 迭代器迭代器有两个基本的方法：iter( 和 next() 字符串，列表或元组对象都可用于创建迭代器 示例： 123456789101112list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=&quot; &quot;)list=[1,2,3,4]it = iter(list) # 创建迭代器对象while True: try: print (next(it)) except StopIteration: sys.exit() StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 函数1.语法12def 函数名（参数列表）: 函数体 可更改(mutable)与不可更改(immutable)对象： 不可变类型：变量赋值 a = 5 后再赋值 a = 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun(a)，传递的只是a的值，没有影响a对象本身。比如在 fun(a)内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后fun外部的la也会受影响 2.参数必需参数： 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，既只要声明了参数，调用时就必须传递 关键字参数：使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 例如： 1234567def printme( name, age ): &quot;打印任何传入的字符串&quot; print (str) return#调用printme函数printme( age = 10, name = &quot;菜鸟教程&quot;) 默认参数：调用函数时，如果没有传递参数，则会使用默认参数,与Kotlin一样 不定长参数：就是可变参数，python的可变参数可以有多种类型，任意指定 例如： 123456789# 可写函数说明def printinfo( arg1, **vardict ):&quot;打印任何传入的参数&quot;print (&quot;输出: &quot;)print (arg1)print (vardict)# 调用printinfo 函数printinfo(1, a=2,b=3) 3.匿名函数语法：lambda [arg1 [,arg2,…..argn]]:expression 示例： 12345# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print (&quot;相加后的值为 : &quot;, sum( 10, 20 )) 4.return语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式，不带参数值的return语句返回None 示例： 1234567def sum( arg1, arg2 ):total = arg1 + arg2print (&quot;函数内 : &quot;, total)return total# 调用sum函数total = sum( 10, 20 ) 变量作用域1.Python的作用域一共有4种 L： （Local） 局部作用域 E： （Enclosing） 闭包函数外的函数中 G： （Global） 全局作用域 B： （Built-in） 内置作用域（内置函数所在模块的范围） 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 示例： 12345g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 全局变量和局部变量，与Java类似 2.global 和 nonlocal 关键字当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字: 示例： 1234567891011num = 1 # 外部作用域定义变量def fun1(): global num # 需要使用 global 关键字声明 print(num) # 注意这两想要打印成功，一方面可思议使用global关键字，如果不适用此关键词声明，可以将num放在方法中传递进来使用，否则将会报错，这里跟Java不同，这是因为 fun1 函数中的 num 使用的是局部，未定义，无法修改。 num = 123 print(num)fun1() # 输出: 1 123print(num) # 输出： 123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字: 示例： 123456789def outer(): num = 10 # 嵌套作用域 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer() 输出 100 100 模块和包1.模块模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能，这也是使用 python 标准库的方法import 语句 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： import module1, module2,... moduleNfrom … import 语句 Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： from modname import name1, name2, ... nameNfrom … import * 语句 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import *dir() 函数 内置的函数 dir() 可以找到模块内定义的所有名称，以一个字符串列表的形式返回2.包包是一种管理 Python 模块命名空间的形式，采用”点模块名称” 比如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B 用户可以每次只导入一个包里面的特定模块，比如: 123import sound.effects.echo这将会导入子模块:sound.effects.echo 它必须使用全名去访问:sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 还有一种导入子模块的方法是: 123from sound.effects import echo这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:echo.echofilter(input, output, delay=0.7, atten=4) 还有一种变化就是直接导入一个函数或者变量: 123from sound.effects.echo import echofilter同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:echofilter(input, output, delay=0.7, atten=4) 基本数据类型变量不需要声明，直接赋值，且赋值后才能使用 1234counter = 1000name = &quot;wangjia&quot;a = b = c = 100 python基本类型 Number（数字） String（字符串） Tuple（元组） List（列表） Set（集合） Dictionary（字典） 注意：前三类是不可变类型 1.python数字类型 Numberint、bool、float、complex（复数） 可以删除对象引用 del var, (del var_a, var_b) 有很多数学函数可以直接调用，比如Java中Math函数中的很多计算函数，在python中直接用就可以，例如 ：abs(-1)，还有一些随机数函数，用的时候查就可以 2.字符串python中没有字符类型，单个字符当做字符串处理 字符串截取：变量[头下标:尾下标] 支持负数，负数代表从后往前截取 使用 “/“ 转义特殊字符，可以在字符串前加 “r” 表示原始字符，例如 r”abc/nvc” 注意字符串格式化： 一般用于日志输出，print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10)) 注意字符串中有四十多个功能内建函数，我们在操作判断关于字符串时查看以后函数是否支持 3.list 列表可以直接初始化: list = [‘12321’, 299, 12.80] 也支持截取，截取方法特性与字符串一样 list是可变的，可以更改元素，list[0] = ‘45654’, 或者批量修改：list[1:3] = [‘45654’, 300, 11.20] 删除元素：list[0] = [], list[0:2] = [] 合并列表，直接 + ，例如： list1 + list2。 list * 2 表示列表元素复制两倍 列表函数： 123456781. 获取长度函数：len(list)2. max(list)：返回列表元素最大值3. min(list)：返回列表元素最小值4. ist(seq)：将元组转换为列表5. list.append(obj)：在列表末尾添加新的对象6. list.index(obj)：从列表中找出某个值第一个匹配项的索引位置7. list.insert(index, obj)：将对象插入列表8. list.remove(obj)：移除列表中某个值的第一个匹配项 del可以根据索引来删除列表元素，例如： del list[2:4] 可以使用append和pop方法将列表作为堆栈使用，等等 4.tuple元组与list类似，但是元素不可变，也支持截取输出 tuple不可变，但是可以包含可变的对象，或list 创建空元组：tup1 = (); 元组不可以修改，但是可组合： tup3 = tup1 + tup2 元组元素不能删除，可以删除整个元组： del tup1 元组运算符支持与list一致 内置函数有：len、max、min、tuple 5.set集合创建方式： set = {1, 2, 3, 4} 或者，set(1) 创建空set 必须使用 set = set() 可以使用 in 关键字判断元素在不在set中， 例如 bool = 2 in set set支持运算，- 表示差集， | 表示并集， &amp; 交集， ^ 不同时存在的元素 基本内置函数： 12341. 添加元素：set.add(元素)2. 删除元素：set.remove( x )3. 计算元素个数：len(s)4. 清空集合：s.clear() 6.Dictionary字典列表是有序的对象集合，字典是无序的对象集合,字典当中的元素是通过键来存取的，类似于map 使用： dict = {} dict[“jjw”] = “wangjia” 字典键不能重复，值无所谓 可以这样创建：d = {key1 : value1, key2 : value2 } 使用字典取值的时候： dict[key] 如果key不存在于字典中，就会抛出异常 字典修改与 Kotlin修改map值一样 删除元素： del dict[key] 字典的键必须是不可变的，不可以使用列表作为键 基本内置函数： 12345671. len(dict)：计算字典元素个数，即键的总数2. str(dict)：输出字典，以可打印的字符串表示，类似于toString()3. radiansdict.get(key, default=None)：返回指定键的值，如果值不在字典中返回default值4. key in dict：如果键在字典dict里返回true，否则返回false5. radiansdict.items()：以列表返回可遍历的(键, 值) 元组数组6. radiansdict.keys()：返回一个迭代器，可以使用 list() 来转换为列表7. radiansdict.values()：返回一个迭代器，可以使用 list() 来转换为列表 遍历字典技巧： 123knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;for k, v in knights.items(): print(k, v) 7.数据转换方法：数据类型(数据) 即可。 例如 ： float(“10.00”) Python运算符数值运算符数值运算可以直接运算，运算的结果是精确的 (+、-、、/、%、*、\\) 主要说明：其他运算符于Java一致， /是精确除法，与Java不一样 ** 是幂，返回x的y次幂 // 取整除,向下取接近除数的整数 类似于我们Java中的 “&quot; 注意以上运算符都支持赋值运算，例如： += 、 *=、 //= 类型判断内置的 type() 函数可以用来查询变量所指的对象类型， isinstance()会判断类型是否属于某种类型 位运算与Java一致 逻辑运算符例如：a = 10; b = 20; and： x and y: 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20 or x or y: 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10 not not x: 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 一般用来判断变量在不在集合中，或者指定字符串中包含不包含特定字符串 身份运算符is: 是判断两个标识符是不是引用自一个对象 is not: 是判断两个标识符是不是引用自不同对象 例如：a = 10; b = 20; a is b 返回结果 true is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等 错误和异常异常即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常，异常的类型有多种，与Java类似 异常处理，使用类似于try-catch语句捕获处理： 12345678for arg in sys.argv[1:]: try: f = open(arg, &apos;r&apos;) except IOError: print(&apos;cannot open&apos;, arg) # 处理异常 else: # else语句表示没有发生任何异常的时候执行的代码块 print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;) f.close() except就类似于catch，except可以处理多个异常： 12except (RuntimeError, TypeError, NameError): pass 抛出异常Python 使用 raise 语句抛出一个指定的异常，示例： 1raise NameError(&apos;HiThere&apos;) 定义清理行为try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为，就是finally代码块，具体执行与Java类似： 123456789def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jjw-story.github.io/tags/Python/"},{"name":"Python基础","slug":"Python基础","permalink":"https://jjw-story.github.io/tags/Python基础/"}],"author":"JJW"},{"title":"vim","slug":"vim","date":"2019-07-20T04:21:42.000Z","updated":"2019-07-25T02:02:10.245Z","comments":true,"path":"2019/07/20/vim/","link":"","permalink":"https://jjw-story.github.io/2019/07/20/vim/","excerpt":"","text":"vi编辑器vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器。 由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 vim vi的多模式 正常模式(Normal-mode) 启动vim后默认处于正常模式，其他模式都可以用ESC键直接转换到正常模式。在这个模式我们键盘所敲的任何按键都是对vim所下的命令，如何进行复制如何进行粘贴都是要在这个模式下进行的。 命令模式(Command-mode) 是指可以在界面最底部的一行输入控制操作命令，主要用来进行一些文字编辑的辅助功能，比如字串搜寻、替代、保存文件，以及退出vim等。在命令行模式下输入”:”，或者是使用”?”和”/”键，就可以进入命令模式了。命令模式下输入的命令都会在最底部的一行中显示，按Enter键vim便会执行命令。 插入模式(Insert-mode) 插入模式用来修改文件内容的，只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 可视模式(Visual-mode) 有一些情况我们要进行一个高级编辑，比如对一块文件进行插入操作，就需要进入此模式。相当于高亮选取文本后的普通模式。在命令模式按下v, V, +v，ctrl+v可以进入可视模式。 vim编辑器所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在，但是目前我们使用比较多的是 vim 编辑器。 vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说，vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 vim正常模式首先使用vim命令进入正常模式，使用方法如下： vim [文件] 文件可以不写，类似于我们Windows记事本一样，可以点击一个文本文档打开，或者直接打开记事本进行编写内容。 正常模式常用命令 在正常模式下可以使用 i、I、a、A、o、O 命令进入到插入模式 i 表示从光标当前位置进入插入模式 I 表示从光标当前所在行的行首进入插入模式 a 表示从光标当前位置的下一位进入插入模式 A 表示从光标当前所在行的行尾进图插入模式 o 表示从当前光标所在行的下一行并插入一行进入插入模式 O 表示从当前光标所在行的上一行并插入一行进入插入模式 v命令 正常模式下输入 v 命令可以进入可视模式 :命令 可以进入命令模式，也称为末行模式 esc命令 在其他模式下可以使用 esc 返回到正常模式 h、j、k、l h 光标向左移动 l 光标向右移动 j 光标向下移动 k 光标向上移动 y复制命令 yy:复制光标所在行到缓冲区 nyy:注意n表示行数，表示复制当前行向下n行的内容 y$:复制当前光标所在位置到行尾的内容 yw:与y$效果一致 ny$:注意n表示字数，表示复制当前光标所在位置后n个字符 d剪切命令 dd:剪切光标所在行到缓冲区 ndd:注意n表示行数，表示剪切当前行向下n行的内容 d$:剪切光标所在位置到行尾的内容 dw:与d$效果一致 p粘贴命令 将复制或剪切的内容粘贴到光标所在位置 u撤销命令 撤销命令，可以将失误的操作进行撤销，如果我们连续失误了很多个命令，就多次使用u命令，一条一条撤销 Ctrl + r 重做撤销命令 就是将使用u命令撤销的命令重做，类似于撤回撤销 x命令 删除光标所在的单个字符 r命令 替换光标所在单个字符，使用时先按r键，再输入新的字符 n + G命令 n表示行数，G是大写，既将光标移动到指定的行 如果不指定 n 则直接将光标跳转到文件的最后一行 ^命令 将光标移动到所在行的行尾 $命令 将光标移动到所在行的行首 vim命令模式下面介绍命令模式常用命令操作 :w [文件名] 如果是新建文件，则使用 :w 文件目录+文件名 来将编辑好的内容保存为指定的文件 如果是修改文件，则直接使用 :w 命令保存文件 :q 使用 :q 退出vim w和q命令可以组合起来使用，直接 :wq 来保存并退出vim 注意：:wq 也可以使用快捷键 shift + z z 来实现 :q! 不保存退出 注意：可以使用快捷键 shift + z + q 来实现 :! 有时候我们在打开vim的时候，需要临时执行一条命令，并查看命令执行的结果，就可以使用 ！ 命令 12345678910111213:!ifconfigroot@CHJ-20190520VPS:/# vim /tmp/test.txteth3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.34.113 netmask 255.255.255.240 broadcast 172.31.34.127 inet6 fe80::4c47:3429:b72c:5130 prefixlen 64 scopeid 0x0&lt;global&gt; ether 7e:15:d8:27:73:38 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ... / + 字符 向下搜索字符，例如使用 /h 可以在文本中查到h出现的地方，并将光标移动到第一次出现的位置 在查找到的时候，我们还可以使用 “n” 键来将光标移动到下一个此字符出现的位置 还可以使用 “shift + n” 来向上查到此字符出现的位置 ? + 字符 向上搜索字符，例如使用 /h 可以在文本中查到h出现的地方，并将光标移动到第一次出现的位置 在查找到的时候，我们还可以使用 “n” 键来将光标移动到下一个此字符出现的位置 还可以使用 “shift + n” 来向上查到此字符出现的位置 :s/旧的字符/新的字符 此命令的作用是将文本中旧的字符替换成新的字符，模式只是将光标当前所在行的字符替换 我们还可以将文本中每一行第一次出现的指定字符替换，可以使用命令 “:%s/旧的字符/新的字符” 如果我们需要将文本跟中所有的指定的字符替换为新的字符，就需要使用命令 “:%s/旧的字符/新的字符/g” ，命令中的g表示global 1234567891011sdaaaaaaaaaaaaaaaaaaaaaasdfsdaaaaasddsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag:%s/a/0/gsd0000000000000000000000sdfsd00000sdds00000000000000000000000000000000000000000000g 有的时候我们需要替换指定的行的特定字符，则需要使用命令 “:3,5/s/旧的字符/新的字符/g”, 表示将第3-5行中的旧的字符替换 :set命令 :set nu: 表示设置显示文本的行号 :set nonu: 表示关闭显示文本的行号 :set hlsearch 在使用查找字符命令时，高亮显示查找到的所有字符 :set nohlsearch 关闭查找字符高亮显示 默认情况下，我们使用set命令设置只在当次vim命令中生效，当我们下次进入vim的时候，set命令设置的东西就又会恢复为默认，这样的话很多时候回造成不必要的麻烦，如果我们需要将set命令设置的内容保存，以便于每次打开都能用，例如 set nu 命令，我们希望每次打开vim编辑文本的时候都能显示行号，这样的话，就需要去修改vim的配置文件，配置文件目录为：/etc/vim/vimrc 我们直接使用 vim /etc/vim/vimrc 命令编辑此配置文件，然后使用 G 命令直接将光标跳转到最后一行，然后使用命令 o 向下插入一行空行，直接编辑我们要设置的内容即可 添加如下： 123456&quot; Source a global configuration file if availableif filereadable(&quot;/etc/vim/vimrc.local&quot;) source /etc/vim/vimrc.localendifset nu 编辑完成之后，使用 esc 退出编辑模式，使用 :wq 保存并退出，这样当我们每次打开文件的时候就都会显示行号 vim插入模式 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 vim可视模式可视模式主要是针对于我们对文件的大量操作使用此模式一次性执行完成，通常我们都是配合 “I”, “d” 命令来快捷操作 可以在正常模式下使用 v、V、Ctrl + v三种方式进入: 命令 进入字符可视模式，字符可视模式就是当我们移动光标的时候，它是以字符为单位进行选择的 V 进入行可视模式，当我们移动光标的时候是对行进行选中 Ctrl + v 进入块可视模式，移动光标时选中的是上下对齐的一个块，此命令是使用较多的命令 使用示例如下： 我们要在多个行中同时插入一下字符，就可以使用vim先打开文件，然后使用 “Ctrl + v” 选中要操作的多个行为块，然后输入 “I” 命令进入行首进行编辑，插入我们要插入的字符后，连续按两次 esc 按键，就会发现，之前选中的行都被添加进去了我们新添加的字符 1234567891011 18 tyutyutyutyutyustyukcdefsdf 19 sdfsdf 20 sdf 21 sdf# 操作完成后 18 wangjia3tyutyutyutyutyustyukcdefsdf 19 wangjia3sdfsdf 20 wangjia3sdf 21 wangjia3sdf 也可以使用 “d” 命令，将选中的块或字符直接删除，使用方法同上，在块选择后，直接输入 d 即可完成删除，此命令比较常用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"vim","slug":"vim","permalink":"https://jjw-story.github.io/tags/vim/"}],"author":"JJW"},{"title":"打包压缩与解压缩","slug":"打包压缩与解压缩","date":"2019-07-17T11:43:36.000Z","updated":"2019-07-18T12:48:43.436Z","comments":true,"path":"2019/07/17/打包压缩与解压缩/","link":"","permalink":"https://jjw-story.github.io/2019/07/17/打包压缩与解压缩/","excerpt":"","text":"打包压缩与解压缩打包与压缩windows常见压缩文件格式：.rar .zip .7z Linux常见压缩文件格式 ：.tar.gz; .tar.bz2; .tgz; tbz2 在linux系统中，文件的格式与后缀名没有关系，一般压缩工具压缩之后会在压缩文件后添加对应压缩工具的后缀名 在Windows中，打包与压缩是一个软件功能，但是在Linux中，它是由两个软件构成的 打包命令Linux早期的打包命令其实是备份命令，备份的介质是磁带，使用的命令是 tar 可以对打包后的磁带文件进行压缩存储，压缩的命令是 gzip 和 bzip2，所以我们可以看到，打包和压缩的命令是分开的 tar命令打包的使用方法：tar [选项] 打包后的文件名 要打包的文件 注意：tar命令 使用tar命令需要了解它的选项，来帮助我们完成打包过程，常用的选项如下： c 建立压缩档案，及打包必须的参数 f 打包成文件并指定文件名称，切记，这个参数是最后一个参数，后面只能接文件名 使用示例： 123root@CHJ-20190520VPS:/# tar cf /tmp/etc-backup.tar /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# 如上示例中，我们将 /etc 目录打包成文件，放置在 /tmp 目录下，并指定打包后的文件名称为 etc-backup.tar ，执行命令后提示会把根目录开头的斜杠 “/“ 去掉，方便我们在解包的时候可以解压到任何目录 压缩命令单纯的打包的打包后的文件一般都很大，因为他并没有做过压缩，一般我们都会在存储的时候进行压缩，如上述打包文件的大小： 12root@CHJ-20190520VPS:/# ls -lh /tmp/etc-backup.tar-rw-r--r-- 1 root root 2.7M Jul 17 20:11 /tmp/etc-backup.tar 通常使用的压缩命令有 gzip bzip2 使用方法如下： gzip [文件名] bzip2 [文件名] 1234root@CHJ-20190520VPS:/# gzip /tmp/etc-backup.tarroot@CHJ-20190520VPS:/# ls -lh /tmptotal 488K-rw-r--r-- 1 root root 459K Jul 17 20:40 etc-backup.tar.gz 在我们使用tar命令的时候，其实已经把这两个命令集成进去了，只需要使用的时候添加参数就可以完成压缩解压缩，下面介绍使用此两个压缩命令的tar选项： z 打包文件并使用gzip压缩文件 j 打包文件并使用bzip2压缩文件 一般在使用打包和压缩命令时，为了方便人看到压缩文件是使用哪种压缩方式压缩的文件，对压缩后的文件使用双扩展名，例如 “xxx.tar.xx”，具体使用如下： 12345678910tar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# tar czf /tmp/etc-backup.tar.gz /etctar: Removing leading `/&apos; from member namesroot@CHJ-20190520VPS:/# ls -lh /tmptotal 1.0Mdrwxr-xr-x 1 root root 4.0K Jul 13 18:34 a-rw-r--r-- 1 root root 437K Jul 17 20:35 etc-backup.tar.bz2-rw-r--r-- 1 root root 459K Jul 17 20:35 etc-backup.tar.gz-rw-r--r-- 1 root root 551 Jul 14 14:03 testtextroot@CHJ-20190520VPS:/# 虽然压缩后的文件都不大，但是能感觉到使用 bzip2 压缩用的时间明显能更长一点，但是 bzip2 压缩后的文件更小一些，因为 bzip2 压缩后的比例更高一些 两种压缩方式都可以，如果我们希望压缩后的比例更高一下，就使用bzip2进行压缩 解压缩命令解压缩我们使用的命令还是 tar 命令，但是需要更换选项 使用方法：tar [参数] 压缩文件 [-C] [解压后目录] 常用选项说明： x 与上述 c 命令对应，x 参数是解压缩参数 f 与上述一致 v 显示所有进程，及压缩或解压明细 C 注意：C是大写，此选项是可以指定解压后的目录地址 使用示例： 12345root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar xf /tmp/etc-backup.tar -C /rootroot@CHJ-20190520VPS:/# ls /rootetc 将/tmp/etc-backup.tar压缩文件解压到 /root 目录下 实际我们见到的很多的压缩文件是 .tbz2 .tgz 的文件，这两种其实是 .tar.bz2 .tar.gz 的缩写，为了方便网络上的传播，将双扩展名的文件进行的缩写 解压我们不需要因为压缩软件的不同而使用不同的选项，只使用标准的 tar 解压就可以，如下： 12345678root@CHJ-20190520VPS:/# ls /tmpetc-backup.tar etc-backup.tar.gz testtextroot@CHJ-20190520VPS:/# tar -xvf /tmp/etc-backup.tar.gz -C /rootetc/etc/.pwd.lock...... 解压文件明细root@CHJ-20190520VPS:/# ls /rootetc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"打包压缩与解压缩","slug":"打包压缩与解压缩","permalink":"https://jjw-story.github.io/tags/打包压缩与解压缩/"}],"author":"JJW"},{"title":"文本查看命令","slug":"文本查看命令","date":"2019-07-15T05:55:16.000Z","updated":"2019-07-14T06:58:51.714Z","comments":true,"path":"2019/07/15/文本查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/15/文本查看命令/","excerpt":"","text":"文本查看命令cat命令显示文本文件内容，适用于查看整体内容，文件内容不多的，将所有的文本内容都显示到终端 使用方法：cat [参数] 文件 参数说明-n 显示的文本的行编号 -e 显示行结束符号$ 示例： 123456root@CHJ-20190520VPS:/tmp# cat -n -E testtext 1 sdf$ 2 $ 3 sd$ 4 f$ 5 ds$ head命令查看文件的开头的内容，默认显示文件开头的前十行 使用方法：head [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的前n行内容 1234root@CHJ-20190520VPS:/tmp# head -3 testtextsdfsd tail命令查看文件的末尾的内容，默认显示文件末的后十行 使用方法：tail [参数] 文件 参数说明-n 注意：n 表示行数，意为查看文件的后n行内容 -f 循环读取文本信息，此命令一般用于文件内容在不断变化的文本查看，一般在查看服务器日志内容时使用 当我们看到文件在一直滚动循环查看，想要停止的时候，使用 ctrl + c命令，退出循环查看，即可停止来具体查看 wc命令wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 参数说明-l 统计文本文件的内容行数，一般我们在使用文本查看命令时，不清粗应该使用哪种命令来查看，可以使用此命令来查看文本的行数，然后选择要使用的文本查看命令 12root@CHJ-20190520VPS:/tmp# wc -l testtext206 testtext -c 统计字节数 -m 统计字符数。这个标志不能与 -c 标志一起使用 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 12root@CHJ-20190520VPS:/tmp# wc -L testtext7 testtext more命令分页显示文件内容，还支持直接跳转行等功能，最大的特点是查看每一页文本内容下方都会显示当前当前查看的文本内容所在位置百分比 使用方法：more 文件名 具体操作 Space：显示文本下一屏内容 Enter：只显示文本下一行内容 b：显示文本上一屏内容 q：退出 less命令分页显示文件内容，操作比more更为详细 使用方法：less [参数] 文件名 参数说明-m 显示类似more命令的百分比 -N 注意这里是大写N，显示每行的行号 具体操作 Space：显示文本下一屏内容 b：显示文本上一屏内容 Enter：前进一行 v：后退一行 d：前进半页 u：后退半页 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 q键：退出","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文本查看命令","slug":"文本查看命令","permalink":"https://jjw-story.github.io/tags/文本查看命令/"}],"author":"JJW"},{"title":"文件管理命令","slug":"文件管理命令","date":"2019-07-11T12:32:46.000Z","updated":"2019-07-14T05:53:08.747Z","comments":true,"path":"2019/07/11/文件管理命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/11/文件管理命令/","excerpt":"","text":"文件管理命令mkdir命令创建目录 使用方法：mkdir [参数] [目录…] 省略号代表可以建立多个目录 例如：建立一个 demo 目录 在根目录下建立：mkdir /demo 在当前目录下建立：mkdir ./demo “./“可以省略 建立多个目录：mkdir demo1 demo2 demo3 如果目录已存在，建立会失败 12root@CHJ-20190520VPS:/# mkdir homemkdir: cannot create directory ‘home’: File exists 参数的使用-p 一次创建多级目录，既父目录不存在先创建父目录 123456789101112root@CHJ-20190520VPS:/# mkdir -p a/b/c/droot@CHJ-20190520VPS:/# ls -R /a/a:b/a/b:c/a/b/c:d/a/b/c/d: 相比Windows，我们发现命令行的好处就在于可以一次创建多级目录 -v 显示目录创建的过程 123root@CHJ-20190520VPS:/# mkdir -p -v /e/fmkdir: created directory &apos;/e&apos;mkdir: created directory &apos;/e/f&apos; rmdir命令删除目录 使用方法：rmdir [目录…] 注意：rmdir 只能删除空的目录，删除非空目录会失败，必须逐级删除目录中的文件 12root@CHJ-20190520VPS:/# rmdir armdir: failed to remove &apos;a&apos;: Directory not empty rm命令删除文件或目录 使用方法：rm [参数] [目录…] 参数的使用-i 交互模式，在删除前询问用户是否操作 -r 如果删除的是目录，则需要使用此参数，作用是即使目录是非空的，也能逐级删除，但是每一级都要手动确认 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 特别需要注意这条命令，注意他的目录是可以写多个的，如果我们的命令写成 “rm -r -f / a “，既 不小心在 “/“ 与 “a” 之间多了一个空格，那么系统下所有的文件都会被删除，而且不会有任何提示。 所以我们在使用此项命令时一定要留意检查，避免操作失误 -r -f 可以合并使用： 12345root@CHJ-20190520VPS:/# mkdir -p a/b/c/d/f/eroot@CHJ-20190520VPS:/# rm -rf aroot@CHJ-20190520VPS:/# lsbin boot dev e etc home init lib lib64 media mnt opt proc root run sbin snap srv sys tmp usr varroot@CHJ-20190520VPS:/# cp命令文件复制命令，copy简写 使用方法： cp [参数] [文件…] 目录 cp [参数] [文件] 文件…目录 参数的使用-r 当我们直接使用cp命令复制目录的时候，是会失败的，因为cp命令本身是只复制文件，递归复制，用于目录的复制操作 12345root@CHJ-20190520VPS:/# cp a /tmpcp: -r not specified; omitting directory &apos;a&apos;root@CHJ-20190520VPS:/# cp -r a /tmproot@CHJ-20190520VPS:/# ls /tmpa -v 复制时显示复制信息，类似进度条，直接复制文件的时候不会有任何提示 12root@CHJ-20190520VPS:/# cp -v /filea /tmp&apos;/filea&apos; -&gt; &apos;/tmp/filea&apos; -p 与文件的属性一起复制，而非使用默认属性，例如文件创建更新时间 -a 与文件的属性一起复制，包括文件的属主，权限等 123456root@CHJ-20190520VPS:/# cp -v -a filea /tmp&apos;filea&apos; -&gt; &apos;/tmp/filea&apos;root@CHJ-20190520VPS:/# ls -l /tmp/filea-rw-r--r-- 1 root root 0 Jul 13 18:47 /tmp/filearoot@CHJ-20190520VPS:/# ls -l filea-rw-r--r-- 1 root root 0 Jul 13 18:47 filea -i 若目标文件已存在，在覆盖时会先询问是否真的操作 123root@CHJ-20190520VPS:/# cp -v -a -i filea /tmpcp: overwrite &apos;/tmp/filea&apos;? yes&apos;filea&apos; -&gt; &apos;/tmp/filea&apos; 注意词命令的第二种语法 表示将文件复制并重命令为自定义名称 12345root@CHJ-20190520VPS:/# cp -v -a -i -r filea /tmp/fileb&apos;filea&apos; -&gt; &apos;/tmp/fileb&apos;root@CHJ-20190520VPS:/# ls /tmpa filea filebroot@CHJ-20190520VPS:/# mv命令mv命令有两个功能，一个是文件及文件夹的移动功能，另一个是重命名功能 使用方法： mv [参数] 源文件 目录…文件名 重命名演示： 1234root@CHJ-20190520VPS:/# mv filea filebroot@CHJ-20190520VPS:/# lsa boot e fileb init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 注意：重命名的本质其实就是将文件移动 移动演示： 123root@CHJ-20190520VPS:/# mv fileb /tmproot@CHJ-20190520VPS:/# ls /tmpa filea fileb 还可以移动并重命名，使用命令： mv filea /tmp/filec 通配符的使用* *号表示匹配当前目录下所有目录及文件 使用示例，例如我们在 /tmp 目录下创建三个文件 filea、filebb、fileccc，然后使用通配符将此三个文件复制到其他目录下 123456root@CHJ-20190520VPS:/tmp# lsa dira dirb dirc filea fileb filecroot@CHJ-20190520VPS:/# cp /tmp/file* /root@CHJ-20190520VPS:/# lsa boot e filea fileccc init lib64 mnt proc run snap sys usrbin dev etc filebb home lib media opt root sbin srv tmp var ? ? 号与 * 作用相同，但是它只匹配一个字符，* 匹配多个字符 1234567891011root@CHJ-20190520VPS:/# lsa boot e home lib media opt root sbin srv tmp varbin dev etc init lib64 mnt proc run snap sys usrroot@CHJ-20190520VPS:/# ls /tmp/file*/tmp/filea /tmp/filebb /tmp/filecccroot@CHJ-20190520VPS:/# cp -v /tmp/file? /&apos;/tmp/filea&apos; -&gt; &apos;/filea&apos;root@CHJ-20190520VPS:/# lsa boot e filea init lib64 mnt proc run snap sys usrbin dev etc home lib media opt root sbin srv tmp var 通过示例我们发现这里只复制过来 filea 目录，所以 ? 表示只匹配一个字符 注意上面我们使用ls命令也是用了通配符，表示通配符可以在很多命令中使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件管理命令","slug":"文件管理命令","permalink":"https://jjw-story.github.io/tags/文件管理命令/"}],"author":"JJW"},{"title":"文件查看命令","slug":"文件查看命令","date":"2019-07-08T04:55:40.000Z","updated":"2019-07-27T06:23:23.261Z","comments":true,"path":"2019/07/08/文件查看命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/08/文件查看命令/","excerpt":"","text":"文件查看命令文件管理命令是Linux管理的核心，因为Linux中有一个非常重要的概念-一切皆文件。在Windows系统中存在注册表、设备管理器了等等各种各样的组建来管理Windows，但是在Linux中，我们系统的管理控制等通通都是文件，所以文件管理命令是Linux管理中非常重要的内容。 pwd命令显示出完整的当前活动目录名称 注意：目录结构中 “/“ 目录和 “/root” 目录是两个不同的目录，”/“目录是我们的根目录，”/root”是root用户的家目录 ls命令列出目录的内容 使用方法：ls [选项] [文件名称…] 如果不写文件名称，默认代表当前目录 省略号表示支持多个文件或者目录名称，多个文件或目录中间用空格隔开（可以用多个空格） 查询内容有颜色不同，代表着不同的权限。不同的客户端颜色展示可能不同 ls基本选项说明-l使用详细格式列表，此命令可以直接缩写为 ll 命令执行如下及结果说明： 123456789root@CHJ-20190520VPS:/usr/lib# ls -ltotal 920drwxr-xr-x 1 root root 4096 May 21 22:39 kerneldrwxr-xr-x 1 root root 4096 May 21 22:39 klibcdrwxr-xr-x 1 root root 4096 May 21 22:40 language-selectorlrwxrwxrwx 1 root root 21 Feb 12 16:55 libDeployPkg.so.0 -&gt; libDeployPkg.so.0.0.0-rw-r--r-- 1 root root 31280 Feb 12 16:55 libDeployPkg.so.0.0.0lrwxrwxrwx 1 root root 20 Feb 12 16:55 libguestlib.so.0 -&gt; libguestlib.so.0.0.0-rw-r--r-- 1 root root 22656 Feb 12 16:55 libguestlib.so.0.0.0 一共查询出七列内容，分别表示： 文件属性(占10个字符空间)、拥有的文件数量、文件的创建者、所属的group、文件大小、建档日期、文件名 重点说明文件属性代表的内容： Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x） 但是这里有十个格子可以添（具体程序实现时，实际上是十个bit位） 第一个小格是特殊表示格，表示目录或连结文件等等，d表示目录，例如drwx——;l表示连结文件，如lrwxrwxrwx;如果是以一横“-”表示，则表示这是文件 其余剩下的格子就以每3格为一个单位，因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。 另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。 -a显示全部文件包括隐藏的文件 Linux隐藏文件的目的是为了在用户日常操作中不会误操作或修改掉一些不可修改的文件内容 Linux创建隐藏文件的方式很简单，只需要在文件名前面加一个 “.” 即可 -t按照文件创建或最后修改的时间排序，默认是根据文件的名称来逆向排序 -r逆向排序显示文件 一般是配合 -l 来使用，例如： ls -l -r 如果我们需要按照文件的创建/修改时间来进行逆向排序则可以使用命令 “-t”，例如： ls -l -r -t 可以组合命令，多个参数不需要每个都用空格隔开，例如上述命令，可以写为： ls -lrt -R递归显示文件，就是罗列出当前文件中所有的文件及文件夹，还有子文件夹中的文件夹及文件，都罗列出来 -h将文件大小数据显示转化为可以阅读清楚的大小表示单位 –full-time列出文件完整的日期时间 –color={auto,never,always}用颜色来表示不同的文件类型，大括号内是参数选项 never：从不使用颜色表示不同类型 always：总是使用颜色表示不同类型 auto：根据终端属性自动确定是否使用颜色表示不同类型 cd命令cd命令用于切换当前工作目录至 dirName(目录参数) 使用方法： cd /path/to…绝对路径 cd /path/to…相对路径 注意一些特殊参数： 路径缺省，表示切换到当前用户的目录 ~ 也是切换到当前用户的目录 / 切换到根目录 ../ 切换到上一层目录，注意 “/“ 可以省略也可以 “cd ../..” 切换到上两级目录 - 切换到上一次访问的目录 12345wangjia3@CHJ-20190520VPS:/home$ pwd/homewangjia3@CHJ-20190520VPS:/home$ cd -/usr/local/libwangjia3@CHJ-20190520VPS:/usr/local/lib$ 当我们要切换的目录离根目录比较近，那就使用绝对路径 当我们要切换的目录离当前目录比较近，那就使用相对路径","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"文件查看命令","slug":"文件查看命令","permalink":"https://jjw-story.github.io/tags/文件查看命令/"}],"author":"JJW"},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2019-07-07T10:00:00.000Z","updated":"2019-07-31T09:08:28.756Z","comments":true,"path":"2019/07/07/IDEA快捷键/","link":"","permalink":"https://jjw-story.github.io/2019/07/07/IDEA快捷键/","excerpt":"","text":"IDEA快捷键 序号 功能 快捷键 1 向上箭头 ctrl+i 2 向上一行选中 ctrl+shfit+i 3 当前行内容向上移动一行 ctrl+alt+i 4 当前行内容向上插入复制一行 ctrl+shift+alt+i 5 向下箭头 ctrl+k 6 向下选中一行 ctrl+shift+k 7 当前行内容向下移动一行 ctrl+alt+k 8 当前行内容向下插入复制一行 ctrl+shift+alt+k 9 END ctrl+o 10 选中到END ctrl+shift+o 11 HOME ctrl+u 12 选中到HOME ctrl+shift+u 13 向左移动一个单词 ctrl+j 14 向左移动一个字母 ctrl+alt+j 15 向左选中一个单词 ctrl+shift+j 16 向左选中一个字母 ctrl+shift+alt+j 17 向右移动一个单词 ctrl+l 18 向右移动一个字母 ctrl+alt+l 19 向右选中一个单词 ctrl+shift+l 20 向右选中一个字母 ctrl+shift+alt+l 21 打开行数跳转框 ctrl+g 22 切换到上一个编辑窗口 ctrl+, 23 切换到下一个编辑窗口 ctrl+. 24 关闭当前编辑窗口 ctrl+w 25 打开查找框 ctrl+f3 26 向下查找 f3 27 向上查找 shift+f3 28 显示意图动作 ctrl+空格，alt+enter 29 project框移动 ctrl+i，ctrl+k 打开关闭：enter 30 删除一行 ctrl+alt+d 31 打开各种功能框 alt+功能框框对应数字 32 打开接口实现类，进入方法内部，获取方法在哪里被调用（类似eclipse的ctrl+alt+h） ctrl+b 33 RUN shift+f9 34 DEBUG shift+f10 35 括号跳转（头-尾） ctrl+m+b","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://jjw-story.github.io/tags/IDEA/"}],"author":"JJW"},{"title":"帮助命令","slug":"帮助命令","date":"2019-07-06T12:58:05.000Z","updated":"2019-07-27T05:13:22.166Z","comments":true,"path":"2019/07/06/帮助命令/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/帮助命令/","excerpt":"","text":"man命令man命令 man是manual的缩写（有问题找男人帮忙） 使用方法：man [章数] [命令] 可以查询到要查询的命令具体作用、参数选项、描述等。查看完毕后按 q 退出 man命令本身也是一个命令，所以可以通过 [man man] 命令查看此命令本身的一些帮助文档 man命令帮助内容man命令帮助内容一共可以有九章的帮助内容，分别如下： Commands 用户可从 shell 运行的命令,查询第一章的内容的时候 1 可以省略 System calls 必须由内核完成的功能，系统调用 Library calls 大多数 libs 函数，如 sort(3) 此命令与第三章命令一般是用在我们在编程过程中获取函数的帮助文档使用的 Special files /dev 目录中的文件，第四章和第五章主要是文件的帮助 File formats and conventions /etc/pass 等人类可读的配置文件等格式及说明 Game Macro packages and conveentions 文件系统标准描述，网络协议，ASCII和其他字符集等 System Management commands 类似 mount(8) 等命令，大部分只能由 root 执行 Kernel routes 废弃的章节，原本是想把一些关于核心的文件放在这里 man一共有九个章节的帮助，分为这么多章主要是因为命令和系统调用还有文件有的时候会出现重名的情况，一旦重名，我们只单用一个man不加章节很难区分 例如 passwd 命令，这个命令是进行用户密码设置的命令，但是在我们的 /etc 目录下，还有一个 passwd 的一个配置文件，如果我们只使用 man passwd 的命令，很难区分出到底是对这个命令的帮助文档，还是对这个配置文件的帮助文档，这时，我们就可以通过章节这个参数来进行区分 有的时候我们并不知道要查看的帮助到底是命令还是配置文件等，可以使用 man a [参数] 来详细查看所有的帮助文档，在查看完一条之后，按 q 退出，即会提示有其他条的帮助文档，我们可以选择查看 man命令说明页含义 标头 含义 Name 命令的名称和用途 Synopsis 命令语法 Description 完整描述 Environment 命令使用的环境变量 Author 开发该程序者 Files 对该命令重要的文件列表 See also 相关信息 Diagnostics 可能的错误和警告 Bugs （可能没有） help命令help命令也是帮助命令，它使用分为内部命令使用帮助、外部命令使用帮助 内部命令和外部命令shell（命令解释器）自带的命令成为内部命令，其他的是外部命令 内部命令内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。 外部命令外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。可通过 “echo $PATH” 命令查看外部命令的存储路径，比如：ls、vi等。 使用type命令区分内外部命令使用方法：type [命令] 1234root@CHJ-20190520VPS:~# type cdcd is a shell builtinroot@CHJ-20190520VPS:~# type mkdirmkdir is /bin/mkdir 内部命令和外部命令最大的区别之处就是性能。内部命令由于构建在shell中而不必创建多余的进程，要比外部命令执行快得多。因此和执行更大的脚本道理一样，执行包含很多外部命令的脚本会损害脚本的性能。 help命令用法 内部命令 help [命令] 外部命令 [命令] --help 帮助命令总结Linux的基本操作方式是命令行，通过命令行的话就需要熟记很多的操作命令，但是海量的命令不适合死记硬背。 当我们使用到陌生的命令的时候，就可以使用 man help 等帮助命令查询它的帮助文档，来帮助我们了解这些命令。 注意：很多内部命令 man 是没有帮助文档的，所以我们使用更多的应该是 help 命令。 which命令查看可执行文件的位置，从全局环境变量PATH里面查找对应的路径，默认是找 bash内所规范的目录，一般用来确认系统中是否安装了指定软件 在PATH变量指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果 使用方法：which [参数] 命令 -a 打印出PATH中的所有匹配项，而不是仅仅第一个 –skip-dot 跳过PATH中以点开头的目录 –skip-tilde 跳过PATH中以波浪号开头的目录 使用示例： 1234root@CHJ-20190520VPS:~# which shutdown/sbin/shutdownroot@CHJ-20190520VPS:~# which cdroot@CHJ-20190520VPS:~# 注意：我们发现查找 cd 命令竟然没有找到，这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"command","slug":"command","permalink":"https://jjw-story.github.io/tags/command/"},{"name":"帮助命令","slug":"帮助命令","permalink":"https://jjw-story.github.io/tags/帮助命令/"}],"author":"JJW"},{"title":"初识Linux","slug":"什么是Linux","date":"2019-07-06T01:49:19.000Z","updated":"2019-07-07T04:57:08.258Z","comments":true,"path":"2019/07/06/什么是Linux/","link":"","permalink":"https://jjw-story.github.io/2019/07/06/什么是Linux/","excerpt":"","text":"什么是LinuxLinux有两种含义 一种是Linus编写的操作系统的内核 另一种是广义的操作系统 一般我们所说的Linux就是说广义的操作系统 服务端操作系统一般都是使用命令行的方式进行操作,主要因为服务端操作系统与客户端操作系统所做的事情不一样,服务端主要追求稳定 Linux版本内核版本 内核版本分为三个部分,一般使用的是稳定版 稳定版又分为三个版本号，分别是 主版本号 次版本号 末版本号 次版本号为奇数为开发版，偶数为稳定版 发行版本 Red Hat EnterPrise 特点：软件经过专业人员的测试，非常稳定，有大公司支持，但是在技术支持和更新最新的安全漏洞补丁的时候是需要付费的 Fedora 特点：也是Red Hat公司发行的，不同之处是发行方式是组建一个社区，来免费提供操作系统，软件要比上述新，但是没有经过专业的测试，稳定性要差 CentOS 特点：基于Red Hat EnterPrise源代码进行编译的，可以免费试用 Ubuntu 特点：定制了非常华丽的界面，可以直接安装在PC机上进行操作 Debian 特点：与Ubantu一样 终端的使用 图形终端 命令行终端 远程终端（SSH VNC） 通过互联网远程连接终端，实际生产使用较多 Linux常见目录介绍 / 根目录 /root root用户的家目录 /home/username 普通用户的家目录 /etc 配置文件目录 /bin 命令目录 /sbin 管理命令目录 /usr/bin /usr/sbin 系统预装的其他命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://jjw-story.github.io/categories/Linux/"}],"tags":[{"name":"overview","slug":"overview","permalink":"https://jjw-story.github.io/tags/overview/"}],"author":"JJW"}]}